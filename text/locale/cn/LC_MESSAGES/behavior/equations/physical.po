# 
msgid ""
msgstr ""
"Project-Id-Version: Modelica by Example 0.2.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-04-14 10:14-0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/behavior/equations/physical.rst:4
msgid "Getting Physical"
msgstr "引入物理"

#: ../../source/behavior/equations/physical.rst:6
msgid ""
"Although the previous section got us started with representing mathematical "
"behavior, it doesn't convey any connection to *physical* behavior.  In this "
"section, we'll explore how to build models that represent the modeling of "
"physical behavior.  Along the way, we will highlight some of the language "
"features we can leverage that will not only tie these models to physical and"
" engineering domains, but, as we shall see, they can even help us avoid "
"mistakes."
msgstr ""
"虽然前面的章节让我们对模型的数学特性有了一定的了解，但是并没有包含与模型\ *物理属性*\ "
"相关的内容。\ "
"在本章节，我们将探索如何建立能体现其物理属性的模型。\ "
"\ "
"在此过程中，我们将重点介绍建模语言的一些特性，利用这些特性不仅可以将模型的物理特性和相应的工程领域结合起来，甚至还可以帮助我们避免一些错误。\ "

#: ../../source/behavior/equations/physical.rst:14
msgid "Let's start with the following example:"
msgstr "让我们先从下面的例子开始："

#: ../../source/behavior/equations/physical.rst:22
msgid ""
"As we saw in the examples in our discussion of :ref:`first-order`, the "
"previous example consists of a ``model`` definition that includes variables "
"and equations."
msgstr "正如我们在前面章节\ :ref:`first-order`\ 中的实例讨论的那样，\ ``model``\ 的定义包括变量和公式。\ "

#: ../../source/behavior/equations/physical.rst:26
msgid ""
"However, this time we see the word ``parameter`` for the first time. "
"Generally speaking, the ``parameter`` keyword is used to indicate variables "
"whose value is known *a priori* (*i.e.*, prior to the simulation).  More "
"precisely, ``parameter`` is a keyword that specifies the *variability* of a "
"variable.  This will be discussed more thoroughly in the section on "
":ref:`variability`.  But for now, we can think of a ``parameter`` as a "
"variable whose value we must provide."
msgstr ""
"但是，上述代码让我们第一次看到了关键字\ ``parameter``\ 。\ "
"一般来说，关键字\ ``parameter``\ "
"用于表明变量的值是先验已知的（即仿真开始之前）。\ "
"更确切的说，关键字\ ``parameter``\ 是用于指定变量的\ *可变性*\ 。\ "
"在\ :ref:`variability`\ 一节中，我们将会对这部分内容进行详细的讨论。\ "
"至于现在，我们可以将关键字\ ``parameter``\ "
"看作是一个必须提供赋值的变量。\ "

#: ../../source/behavior/equations/physical.rst:35
msgid ""
"Looking at our ``NewtonCooling`` example, we see there are five parameters: "
"``T_inf``, ``T0``, ``h``, ``A``, ``m`` and ``c_p``.  We don't need to bother"
" explaining what these variables are because the model itself includes a "
"descriptive string for each one.  At the moment, there are no values for "
"these parameters, but we will return to that topic shortly.  As with all the"
" variables we have seen so far, these are all of type ``Real``."
msgstr ""
"在\ ``NewtonCooling``\ 实例中，我们可以看到五个参数：\ "
"\ ``T_inf``\  、\ ``T0``\  、\ ``h``\  、\ ``A``\  、\ \ ``m``\ 以及\ ``c_p``\ 。\ "
"我们不需要费心的去解释这些变量的含义，因为模型本身已经为每个变量添加了描述性的字符串。\ "
"目前，这些参数都没有赋值。\ "
"但是我们很快会回到这个话题。\ "
"迄今为止，我们所看到的变量类型都是\ ``Real``\ 。\ "

#: ../../source/behavior/equations/physical.rst:43
msgid ""
"Let's examine the rest of this model.  The next variable is ``T`` (also a "
"``Real``).  Since this variable doesn't have the ``parameter`` qualifier, "
"its value is determined by the equations in the model."
msgstr ""
"让我们来研究一下这个模型的其余部分。\ "
"下一个变量名是\ ``T``\ （数据类型也是\ ``Real``\ ）。\ "
"因为这个变量没有关键字\ "
"``parameter``\ 的限定，因此，它的值是通过模型中的方程确定的"

#: ../../source/behavior/equations/physical.rst:47
msgid ""
"Next we see the two ``equation`` sections.  The first is an ``initial "
"equation`` section which specifies how the variable ``T`` should be "
"initialized.  It should be pretty clear that the initial value for ``T`` is "
"going to be whatever value was given (by us) for the parameter ``T0``."
msgstr ""
"接下来，我们看到的是两个\ ``equation``\ 部分。\ "
"第一个是\ ``initial equation``\ 区域。\ "
"该部分指定变量\ "
"``T``\ 如何进行初始化。\ "
"从上面\ ``initial equation``\ 区域可以清楚的看到，变量\ ``T``\ "
"的初始值是由参数\ ``T0``\ 决定的，因此我们可以为它赋任何初值。\ "

#: ../../source/behavior/equations/physical.rst:53
msgid ""
"The other equation is the differential equation that governs the behavior of"
" ``T``.  Mathematically, we could express this equation as:"
msgstr "另一条方程是关于参数\ ``T``\ 的微分方程。\ "
"数学上，我们可以用以下方程进行描述："

#: ../../source/behavior/equations/physical.rst:58
msgid "but in Modelica, we write it as:"
msgstr "但是，在Modelica语言中，我们将它写成如下形式："

#: ../../source/behavior/equations/physical.rst:64
msgid ""
"Note that this is really no different from the equation we saw in our "
"``FirstOrder`` model from the :ref:`first-order` example."
msgstr ""
"我们可以注意到，本实例和\ :ref:`first-order`\ 的\ ``FirstOrder``\ "
"模型实例相比，在公式的写法上并没有什么不同。\ "

#: ../../source/behavior/equations/physical.rst:67
msgid ""
"One thing worth noting is that the equation in our ``NewtonCooling`` example"
" contains an **expression** on the left hand side.  In Modelica, it is "
"**not** necessary for each equation to be an explicit equation for a single "
"variable.  An equation can contain arbitrary expressions on either side of "
"the equals sign.  It is the compiler's job to determine how to use these "
"equations to solve for the variables contained in the equations."
msgstr ""
"有一点值得注意的是，在\ ``NewtonCooling``\ 实例中的方程，等式左侧也包含相应的\ **表达式**\ "
"。\ "
"在Modelica中，\ **没有**\ "
"必要去明确某个方程是哪个单一变量的确定方程。\ "
"一个公式可以在等号的两边包含任意表达式。\ "
"通过确定如何使用这些方程，然后求解包含在等式中的变量是编译器的工作。\ "

#: ../../source/behavior/equations/physical.rst:75
msgid ""
"Another thing that distinguishes our ``NewtonCooling`` example from the "
"``FirstOrder`` model is that we can independently adjust the different "
"parameter values.  Furthermore, these parameter values are tied to physical,"
" measurable properties of the materials or environmental conditions.  In "
"other words, this version is slightly more physical than the simple "
"mathematical relationship used in the ``FirstOrder`` model because it is "
"related to physical properties."
msgstr ""
"另一个区分\ ``NewtonCooling``\ 和\ ``FirstOrder``\ "
"模型实例的特点是我们可以独立的调整不同参数的值。\ "
"此外，这些参数的值和模型的物理特性，材料或环境条件的可测量特性相关联。\ "
"换句话说，相比于\ ``FirstOrder``\ 实例中的简单数学关系，\ "
"这个版本稍微能体现实际系统的物理特性，因为模型参数本身就是和物理属性相关联的。\ "

#: ../../source/behavior/equations/physical.rst:83
msgid ""
"Now, we can't really run the ``NewtonCooling`` model as is because it lacks "
"*values* for the six parameters.  In order to create a model that is ready "
"to be simulated, we need to provide those values, *e.g.*,"
msgstr ""
"现在，我们还不能运行\ ``NewtonCooling``\ 模型，因为缺少六个参数\ *值*\ 。\ "
"为了创建可以用于仿真的模型，我们需要提供上述参数值，即："

#: ../../source/behavior/equations/physical.rst:92
msgid ""
"The only real difference here is that each of the ``parameter`` variables "
"now has a value specified.  One way to think about the ``NewtonCooling`` "
"model is that we could not simulate it because it had 7 variables (total) "
"and only one equation (see the section on :ref:`initialization` for an "
"explanation of why the ``initial equation`` doesn't really count).  However,"
" the ``NewtonCoolingWithDefaults`` model has, conceptually speaking, 7 "
"equations (6 of them coming from specifying the values of the ``parameter`` "
"variables + one in the equation section) and 7 unknowns."
msgstr ""
"这里唯一的区别是，关键字\ ``parameter``\ 后面的变量都有了确定值。\ "
"一种分析\ ``NewtonCooling``\ "
"模型不能仿真原因的方法在于，模型总共包含7个变量却只有一个方程（参考\ :ref:`initialization`\ 以了解\ ``initial"
" equation``\ 区域不能算作方程的原因）。\ "
"但是，从概念上讲，\ ``NewtonCoolingWithDefaults``\ 模型包含7个方程\ "
"（6个方程是对\ ``parameter``\ 中变量的初始化，另一个在方程区域）和7个未知量。\ "

#: ../../source/behavior/equations/physical.rst:102
msgid ""
"If we simulate the ``NewtonCoolingWithDefaults`` model, we get the following"
" solution for ``T``."
msgstr "如果我们将\ ``NewtonCoolingWithDefaults``\ 模型进行仿真，可以得到变量\ ``T``\ 解的轨迹，如下所示："

#: ../../source/behavior/equations/physical.rst:111
msgid "Physical Units"
msgstr "物理单位"

#: ../../source/behavior/equations/physical.rst:113
msgid ""
"As mentioned already in this section, these examples are a bit more physical"
" because they include individual physical parameters that correspond to "
"individual properties of our real world system. However, we are still "
"missing something.  Although these variables represent physical quantities "
"like temperature, mass, *etc.*, we haven't explicitly given them any "
"physical types."
msgstr ""
"正如本节已经提到的那样，这些例子体现更多的物理属性。\ "
"因为，模型包含各自对应于现实世界体系中各个属性的物理参数。\ "
"然而，我们仍然缺少一些物理属性。\ "
"尽管这些变量代表了物理量如温度，质量等方面，我们并没有明确为其规定任何物理类型。\ "

#: ../../source/behavior/equations/physical.rst:120
msgid ""
"As you may have already guessed, the variable ``T`` is a temperature. This "
"is made clear in the descriptive text associated with the variable.  "
"Furthermore, it doesn't take a very deep analysis of our previous model to "
"determine that ``T0`` and ``T_inf`` must also be temperatures."
msgstr ""
"正如你猜测的那样，变量\ ``T``\ "
"表示温度，在与变量相关的描述性文本中已经明确进行了表述。\ "
"此外，即使不对此前的模型进行很深入的分析，大家也可以确定变量\ ``T0``\ 和\ "
"``T_inf``\ 均须是温度。\ "

#: ../../source/behavior/equations/physical.rst:126
msgid ""
"But what about the other variables like ``h`` or ``A``?  What do they "
"represent?  Even more important, are the equations **physically "
"consistent**?  By physically consistent, we mean that both sides of the "
"equations have the same physical units (*e.g.*, temperature, mass, power)."
msgstr ""
"但是对于其他变量，比如变量\ ``h``\ 或\ ``A``\ ，它们表示什么？更重要的是，这些方程是否\ **具有物理一致性**\ "
"？物理一致性表述的是方程等式两边是否具有相同的物理单位（即温度、质量、功率等）。\ "

#: ../../source/behavior/equations/physical.rst:132
msgid ""
"We could convey the physical units of the different variables more "
"rigorously by actually including them in the variable declarations, like so:"
msgstr "我们可以通过在变量声明的时候包含相应的物理单位，以更严格地表述不同变量的单位。\ "
"如下所示："

#: ../../source/behavior/equations/physical.rst:142
msgid ""
"Note that each of the variable declarations now includes the text "
"``(unit=\"...\")`` to associate a physical unit with the variable.  What "
"this additional text does is specify a value for the ``unit`` attribute "
"associated with the variable.  Attributes are special properties that each "
"variable has.  The set of attributes a variable can have depends on the type"
" of the variable (this is discussed in more detail in the upcoming section "
"on :ref:`variables`)."
msgstr ""
"你可以注意到，每个变量的声明部分都包含与变量相关联的物理单元文本\ ``(unit=\"...\")``\ "
"。\ "
"这些附加文本的作用是为了指定与变量相关联的\ ``unit``\ "
"（物理单位）属性值。\ "
"属性是每个变量所具有的特质。\ "
"变量的属性集取决于变量的类型（在接下来的章节将对变量部分进行更详细的讨论，参考\ "
":ref:`variables`\ ）。\ "

#: ../../source/behavior/equations/physical.rst:150
msgid ""
"At first glance, it may not seem obvious why specifying the unit attribute "
"(*e.g.*, ``(unit=\"K\")``) is any better than simply adding "
"``\"Temperature\"`` to the descriptive string following the variable. In "
"fact, one might even argue it is worse because \"Temperature\" is more "
"descriptive than just a single letter like \"K\"."
msgstr ""
"初看起来，似乎不是很明白，指定变量的物理单位属性（比如\ ``(unit=\"K\")``\ ）还不如简单在变量声明的后面添加描述性字符串\ "
"``\"Temperature\"``\ "
"。\ "
"事实上，人们甚至可以说指定变量的物理属性更糟糕。\ "
"因为\"Temperature\"比单一的字母\"K\"更具有描述性。\ "

#: ../../source/behavior/equations/physical.rst:156
msgid ""
"However, setting the ``unit`` attribute is actually a more formal approach "
"for two reasons.  The first reason is that the Modelica specification "
"defines relationships for all the standard SI unit attributes (*e.g.*, "
"``K``, ``kg``, ``m``).  This includes complex unit types that can be "
"composed of other base units (*e.g.*, ``N``)."
msgstr ""
"然而，设置\ ``unit``\ （单位）属性实际上有两个原因。\ "
"第一个原因是，Modelica语言规范定义了所有标准国际单位属性之间的关系（例如\"
" ``K``\ 、\ ``kg``\ 、\ ``m``\ ）。\ "
"这包括由其他基本单位构成的复杂单位类型 (例如\ ``N``\ ) 。\ "

#: ../../source/behavior/equations/physical.rst:162
msgid ""
"The other reason is that the Modelica specification also defines rules for "
"how to compute the units of complex mathematical expressions.  In this way, "
"the Modelica specification defines everything that is necessary to **unit "
"check** Modelica models for errors or physical inconsistencies.  This is a "
"big win for model developers because adding units not only makes the models "
"clearer, it provides better diagnostics in the case of errors."
msgstr ""
"另一个原因是，Modelica语言还规定了如何进行复杂数学表达式单位计算的规则。\ "
"在这种方式下，Modelica语言标准定义了所有与\ **单位属性检查**\ "
"相关的规则，以便检测Modelica模型中单位属性的错误或不一致。\ "
"这对模型开发者来说是一个巨大的优势，因为添加物理单位属性不仅使得模型结构更清晰，而且还提供了出现错误情况下更好的诊断方法。\ "

#: ../../source/behavior/equations/physical.rst:173
msgid "Physical Types"
msgstr "物理类型"

#: ../../source/behavior/equations/physical.rst:175
msgid ""
"But truth be told, there is one drawback of the code for our "
"``NewtonCoolingWithUnits`` example and that is that we have to repeat the "
"``unit`` attribute specification for every variable.  Furthermore, as "
"mentioned previously, ``K`` isn't nearly as descriptive as \"Temperature\"."
msgstr ""
"但是，实际上在\ ``NewtonCoolingWithUnits``\ 实例中有一个缺陷，\ "
"即我们必须对每个变量的\ ``unit``\ 属性重复定义。\ "
"另外，如前所述，“Temperature”比单一字母\ ``K``\ 更具有描述性。\ "

#: ../../source/behavior/equations/physical.rst:183
msgid ""
"Fortunately, we have a simple solution to both problems because Modelica "
"allows us to define *derived types*.  So far, all the variables we have "
"declared have been of type ``Real``.  The problem with ``Real`` is that it "
"could be anything (*e.g.*, a voltage, a current, a temperature).  What we'd "
"like to do is narrow things down a bit.  This is where derived types come "
"in.  To see how to define derived types and then use them in declarations, "
"consider the following example:"
msgstr ""
"幸运的是，对上述问题我们有一个简单的解决方法，即Modelica语言允许我们定义\ *derived types*\ "
"（派生类型）。\ "
"到目前为止，我们所声明的变量类型只有\ ``Real``\ （实型）。\ "
"\ ``Real``\ 类型的问题是它可以是任何东西（例如：电压、电流、温度）。\ "
"我们想做的是如何稍微限制一下变量类型。\ "
"这也就是派生类型产生的原因。\ "
"要了解如何定义和声明派生类型，考虑下面的例子："

#: ../../source/behavior/equations/physical.rst:199
msgid ""
"You can read the definition ``type Temperature=Real(unit=\"K\", min=0);`` as"
" \"Let us define a new type, ``Temperature``, that is a specialization of "
"the built-in type ``Real`` with physical units of Kelvin (``K``) and a "
"minimum possible value of ``0``\"."
msgstr ""
"你可以看到关于类型的定义\ ``type Temperature=Real(unit=\"K\", min=0);``\ 。\ "
"其意思是“让我们定义一个新类型\ ``Temperature``\ 。\ "
"这是内置\ ``Real``\ 类型的一个特例。\ "
"其物理单位为开尔文（\ ``K``\ ）。\ "
"最小可能值则为\ ``0``\ ”。\ "

#: ../../source/behavior/equations/physical.rst:204
msgid ""
"From this example, we can see that once we define a physical type like "
"``Temperature``, we can use it to declare multiple variables (*e.g.*, ``T``,"
" ``T_inf`` and ``T0``) without having to specify the ``unit`` or ``min`` "
"attribute for each variable.  Also, we get to use the familiar name "
"``Temperature`` instead of the SI unit, ``K``.  You might be wondering what "
"other attributes are available when creating derived types.  For further "
"discussion, see the section on :ref:`builtin-types`."
msgstr ""
"从这个例子中，我们可以看到，一旦我们定义了一个物理类型比如\ ``Temperature``\ ，我们可以使用它为多个变量（例如\ ``T``\"
" 、\ ``T_inf``\ 和\ ``T0``\ ）进行声明，而无需为每一个变量指定\ ``unit``\ （单位属性）或\ "
"``min``\ （最小值属性）。\ "
"另外，我们可以使用所熟悉的名字\ ``Temperature``\ 来代替国际单位\ ``K``\ "
"。\ "
"你可能想知道为什么创建了派生类型后，其他变量也可以获取其属性。\ "
"如果需要进一步的了解，可以参考章节\ :ref:`builtin-types`\ 。\ "

#: ../../source/behavior/equations/physical.rst:213
msgid ""
"At this point, you might find the idea of defining ``Temperature``, "
"``ConvectionCoefficient``, ``SpecificHeat`` and ``Mass`` in every model "
"extremely tedious.  It would be, if it were truly necessary. But don't "
"worry, there is an easy solution to this as you will see in a later section "
"where we discuss :ref:`importing_physical_types`."
msgstr ""
"在这一点上，你会发现若要在每一个模型中都要定义变量\ ``Temperature``\ 、\ "
"``ConvectionCoefficient``\ 、\ ``SpecificHeat``\ 、\ ``Mass``\ ，这会是一件极其乏味的事情。\ "
"但如果模型有这方面需要的话，还必须这样做。\ "
"不过，不用担心。\ "
"我们会在后面关于\ :ref:`importing_physical_types`\ 的章节中讨论一个简单的解决方案。\ "

