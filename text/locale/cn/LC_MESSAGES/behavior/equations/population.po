#
msgid ""
msgstr ""
"Project-Id-Version: Modelica by Example 0.2.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-04-14 10:14-0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/behavior/equations/population.rst:4
msgid "Lotka-Volterra Systems"
msgstr "猎食者猎物系统"

#: ../../source/behavior/equations/population.rst:6
msgid ""
"So far, we've seen thermal, electrical and mechanical examples.  In effect, "
"these have all been engineering examples.  However, Modelica is not limited "
"strictly to engineering disciplines.  To reinforce this point, this section "
"will present a common ecological system dynamics model based on the "
"relationship between predator and prey species. The equations we will be "
"using are the [Lotka]_-[Volterra]_ equations."
msgstr ""
"目前为止，我们已经介绍了热学、电学和机械方面的实例。\ "
"实际上，这些都是工程实例。\ "
"然而，Modelica语言并不仅限于工程科学。\ "
"为了强化这一点，本节将介绍基于猎食者和猎物之间关系的共同生态系统动力学模型。\ "
"我们将使用\ [Lotka]_-[Volterra]_\ 方程去建立上述模型。\ "

#: ../../source/behavior/equations/population.rst:16
msgid "Classic Lotka-Volterra"
msgstr "经典猎食者猎物系统"

#: ../../source/behavior/equations/population.rst:18
msgid ""
"The `classic Lotka-Volterra model <http://en.wikipedia.org/wiki/Lotka-"
"Volterra_equation>`_ involves two species.  One species is the \"prey\" "
"species.  In this section, the population of the prey species will be "
"represented by :math:`x`.  The other species is the \"predator\" species "
"whose population will be represented by :math:`y`."
msgstr ""
"\ `\ 经典的猎食者猎物模型\ <http://en.wikipedia.org/wiki/Lotka-"
"Volterra_equation>`_\ 涉及两个物种。\ "
"一个物种叫做“猎物”。\ "
"本节中，其物种种群用\ :math:`x`\ 表示。\ "
"另一个物种称为“猎食者”，其物种种群用\ :math:`y`\ 表示。\ "

#: ../../source/behavior/equations/population.rst:25
msgid ""
"There are three important effects in a Lotka-Volterra system.  The first is "
"reproduction of the \"prey\" species.  It is assumed that reproduction is "
"proportional to the population.  If you are familiar with chemical "
"reactions, this is conceptually the same as the `Law of Mass Action "
"<http://en.wikipedia.org/wiki/Law_of_mass_action>`_ [Guldberg]_.  If you "
"aren't familiar with the Law of Mass Action, just consider that the more "
"potential mates are present in the environment, the more likely reproduction"
" is to occur.  We can represent this mathematically as:"
msgstr ""
"有三个因素对猎食者猎物系统影响较大。\ "
"首先是“猎物”物种的繁殖率。\ "
"假设其繁殖率和种群成正比。\ "
"如果你对化学反应比较熟悉，\ `\ 质量作用定律\ "
"<http://en.wikipedia.org/wiki/Law_of_mass_action>`_ [Guldberg]_ \ "
"和其在概念上是完全相同的。\ "
"如果你对质量作用定律不了解，可以理解为生存环境中潜在的配偶越多，种群的繁殖率就会越高。\ "
"我们可以用数学公式表达如下："

#: ../../source/behavior/equations/population.rst:37
msgid ""
"where :math:`x` is the prey population, :math:`\dot{x}_r` is the change in "
"prey population *due to reproduction* and :math:`\alpha` is the "
"proportionality constant capturing the likelihood of successful "
"reproduction."
msgstr ""
"其中，\ :math:`x`\ 表示猎物的种群，\ :math:`\alpha`\ 表示种群繁殖率的比例常数，\ "
":math:`\dot{x}_r`\ 表示\ *由于繁殖*\ 引起的种群变化。\ "

#: ../../source/behavior/equations/population.rst:42
msgid ""
"The next effect to consider is starvation of the predator species.  If there"
" aren't enough \"prey\" around to eat, the predator species will die off.  "
"When modeling starvation, it is important to consider the effect of "
"competition.  We again have a proportionality relationship, but this time it"
" works in reverse because, unlike with prey reproduction, the more predators"
" around the more likely starvation is.  This is expressed mathematically in "
"much the same way as reproduction:"
msgstr ""
"其次影响猎食者猎物系统的因素是猎食者的饥饿程度。\ "
"如果没有足够的“猎物”来充饥，部分猎食者就会饿死。\ "
"在建模饥饿程度时，要考虑竞争关系对其的重要影响。\ "
"我们也是用比例关系描述上述模型。\ "
"不同于繁殖率模型，此次是反比例关系，因为越多的猎食者越容易引发饥饿。\ "
"在数学表达式上，这和繁殖率模型具有相同的表达形式："

#: ../../source/behavior/equations/population.rst:53
msgid ""
"where :math:`y` is the predator population, :math:`\dot{y}_s` is the change"
" in predator population *due to starvation* and :math:`\gamma` is the "
"proportionality constant capturing the likelihood of starvation."
msgstr ""
"其中，\ :math:`y`\ 表示猎食者种群。\ "
"\ :math:`\gamma`\ 表示种群饥饿的比例常数。\ "
"\ "
":math:`\dot{y}_s`\ 表示\ *由于饥饿*\ 引起的猎食者种群变化。\ "

#: ../../source/behavior/equations/population.rst:79
msgid ""
"where :math:`\dot{x}_p` is the decline in the prey population *due to "
"predation*, :math:`\dot{y}_p` is the increase in the predator population "
"*due to predation*, :math:`\beta` is the proportionality constant "
"representing the likelihood of prey consumption and :math:`\delta` is the "
"proportionality constant representing the likelihood that the predator will "
"have sufficient extra nutrition to support reproduction."
msgstr ""
"其中，\ :math:`\dot{x}_p`\ 表示\ *由于捕食*\ 而导致的猎物种群减少。\ "
"\ :math:`\dot{y}_p`\ "
"表示\ *由于捕食*\ 而导致猎食者种群的增加。\ "
"\ :math:`\beta`\ 表示捕获猎物概率的比例常数。\ "
"\ "
":math:`\delta`\ 表示猎食者由于足够的营养以提高繁殖率可能性的比例常数。\ "

#: ../../source/behavior/equations/population.rst:86
msgid ""
"Taking the various effects into account, the overall change in each "
"population can be represented by the following two equations:"
msgstr "全面考虑各种因素，可以得到每个种群的整体变化。\ "
"用以下两个方程表示："

#: ../../source/behavior/equations/population.rst:94
msgid ""
"Using the previous relationships, we can expand each of the right hand side "
"terms in these two equations into:"
msgstr "根据上述两个方程，通过数学运算，可以重新整合方程等式的右侧，得到如下方程组："

#: ../../source/behavior/equations/population.rst:102
msgid ""
"Using what we've learned in this chapter so far, translating these equations"
" into Modelica should be pretty straightforward:"
msgstr "根据前几章我们学到的知识，将上述方程转化成Modelica语言应该相当简单："

#: ../../source/behavior/equations/population.rst:111
msgid ""
"At this point, there is only one thing we haven't discussed yet and that is "
"the presence of the ``start`` attribute on ``x`` and ``y``. As we saw in the"
" ``NewtonCoolingWithUnits`` example in the previous section titled :ref"
":`getting-physical`, variables have various attributes that we can specify "
"(for a detailed discussion of available attributes, see the upcoming section"
" on :ref:`builtin-types`).  We previously discussed the ``unit`` attribute, "
"but this is the first time we are seeing the ``start`` attribute."
msgstr ""
"在上述代码中，只有一点我们还没有讨论，即变量\ ``x``\ 和\ ``y``\ 的\ ``start``\ 属性。\ "
"正如我们在前面\ :ref:`getting-physical`\ 章节里对\ ``NewtonCoolingWithUnits``\ "
"示例所介绍的那样，我们可以为变量指定各种的属性\ "
"（在后面的章节\ :ref:`builtin-types`\ 中将详尽地讨论变量的属性）。\ "
"我们已经在前面章节讨论了变量的\ ``unit``\ 属性。\ "
"这是我们第一次看到\ ``start``\ 属性。\ "

#: ../../source/behavior/equations/population.rst:120
msgid ""
"The observant reader may have noticed the presence of the ``x0`` and ``y0`` "
"parameter variables and the fact that they represent the initial "
"populations.  Based on previous examples, one might have expected these "
"initial conditions to be captured in the model as follows:"
msgstr ""
"细心的读者可能已经注意到程序中对变量\ ``x0``\ 和\ ``y0``\ "
"的声明以及其所代表的种群初始值。\ "
"根据前面实例的讲解，有人可能认为这些初始化条件是以如下的方式被模型获取的："

#: ../../source/behavior/equations/population.rst:131
msgid ""
"However, for the ``ClassicModel`` example we took a small shortcut. As will "
"be discussed shortly in the section on :ref:`initialization`, we can specify"
" initial conditions by specifying the value of the ``start`` attribute "
"directly on the variable."
msgstr ""
"然而，对于\ ``ClassicModel``\ 示例，我们采用了更简洁的方法。\ "
"我们可以在声明变量的\ ``start``\ "
"属性时直接指定其初始条件。\ "
"在\ :ref:`initialization`\ 章节中将对这一功能做简单的介绍"

#: ../../source/behavior/equations/population.rst:136
msgid ""
"It is worth noting that this approach has both advantages and disadvantages."
"  The advantage is one of flexibility.  The ``start`` attribute is actually "
"more of a hint than a binding relationship.  If the Modelica compiler "
"identifies a particular variable as a state (*i.e.*, a variable that "
"requires an initial condition) **and** there are insufficient initial "
"conditions already explicitly specified in the model via ``initial "
"equation`` sections then it can substitute the ``start`` attribute as an "
"initial condition for the variable it is associated with.  In other words, "
"you can think of the ``start`` attribute as a \"fallback initial condition\""
" if an initial condition is needed."
msgstr ""
"值得注意的是，这种方法既有优点也有缺点。\ "
"方法的优点是比较灵活。\ "
"其实，\ ``start``\ 属性更多的是一种绑定关系的暗示。\ "
"如果Modelica编译器将某个特定变量识别为状态\ "
"（即某个变量需要一个初始化条件），\ **并且**\ 模型的\ "
"``initial equation``\ 部分没有提供非充足的初始条件，这时\ ``start``\ "
"属性就可以作为替代，声明变量的初始条件。\ "
"换句话说，你可以认为\ ``start``\ 属性是在必须具备初始条件的情况下的“后备初始条件”。\ "

#: ../../source/behavior/equations/population.rst:148
msgid ""
"There are a couple of disadvantages to the ``start`` attribute that you need"
" to watch out for.  First, it is only a hint and tools may completely ignore"
" it.  Next, whether it will be ignored is also hard to predict since "
"different tools may make different choices about which variables to treat as"
" states."
msgstr ""
"你需要注意\ ``start``\ "
"属性所具备的一些缺点。\ "
"首先，此属性只是一个完全可以忽略的提示工具。\ "
"其次，其是否被忽略也很难预测。\ "
"因为哪些变量作为状态在不同的工具里选择也会不同。\ "

#: ../../source/behavior/equations/population.rst:182
msgid ""
"Whether to specify a ``start`` attribute or not depends on how strictly you "
"want a given initial condition to be enforced.  Knowing that is something "
"that takes experience working with the language and is beyond the scope of "
"this chapter.  However, it is worth at least pointing out that there are "
"different options along with a basic explanation of the trade-offs."
msgstr ""
"是否指定一个变量的\ ``start``\ "
"属性取决于你希望初始条件会得到多严格的。\ "
"决定这点对于需要对语言有一定的经验。\ "
"而这已经超出了本书的范围。\ "
"然而，至少值得在这里指出不同选择的存在，以及简单解释一下权衡要素。\ "

#: ../../source/behavior/equations/population.rst:189
msgid ""
"Using either initialization method, the results for these models will be the"
" same.  The typical behavior for the Lotka-Volterra system can be seen in "
"this plot:"
msgstr "不管使用哪种初始化的方法，这些模型的仿真结果都是相同的。\ "
"猎食者猎物系统的典型结果如下图所示："

#: ../../source/behavior/equations/population.rst:196
msgid ""
"Note the cyclical behavior of each population.  Initially, there are more "
"predators than can be supported by the existing food supply. Those predators"
" that are present consume whatever prey the can find. Nevertheless, some "
"starvation occurs and the predator population declines.  The rate at which "
"predators consume the prey species is so high during this period that the "
"rate at which the prey species reproduces is not sufficient to make up for "
"those lost to predation so the prey population declines as well."
msgstr ""
"通过上图，可以看到每个种群的周期性行为。\ "
"最初，没有充足的食物来支撑较多的猎食者。\ "
"存在的猎食者捕食任何可以找到的猎物。\ "
"但即便如此，饥饿还是会发生并且导致猎食者种群数量的下降。\ "
"在此期间，猎食者消耗猎物种群的速率如此之高，\ "
"以致于猎物种群的繁殖速率不足以弥补因捕食而减少的种群数。\ "
"因此，猎物种群的数量也在下降。\ "

#: ../../source/behavior/equations/population.rst:205
msgid ""
"At some point, the predator population gets so low that the rate of "
"reproduction in the prey species is larger than the rate of prey consumption"
" by the predators and the prey species begins to rebound. Because the "
"predator species population takes longer to rebound, the prey species "
"experiences growth that is, for the moment, virtually unchecked by "
"predation.  Eventually, the predator population begins to rebound due to the"
" abundance of prey until the system returns to the original predator and "
"prey populations **and the entire cycle then repeats itself** *ad "
"infinitum*."
msgstr ""
"在某些点上，猎食者种群的数量变的如此之低，\ "
"导致猎物种群的繁殖数量高于因捕食而减少的种群数。\ "
"猎物物种的数量开始反弹。\ "
"因为猎食者种群大小的回升需要较长的时间。\ "
"所以在此期间，猎物种群的增长速度几乎不受猎食者种群的影响。\ "
"最终，由于猎物的丰盛，猎食者种群的数量开始回升，\ "
"之至系统恢复到猎食者和猎物种群的原始状态，然后\"
" **整个循环再重演**\ ，无穷无尽。\ "

#: ../../source/behavior/equations/population.rst:215
msgid ""
"The fact that the system returns again and again to the same initial "
"conditions (ignoring numerical error, of course) is one of the most "
"interesting things about the system.  This is even more remarkable given the"
" fact that the Lotka-Volterra system of equations is actually non-linear."
msgstr ""
"该系统一次次的返回到相同的初始条件处（当然要忽略数值计算错误）。\ "
"这一现象是系统最有趣的地方之一。\ "
"特别是考虑猎食者猎物系统方程实际上是非线性的，这也就更加令人注目了。\ "

#: ../../source/behavior/equations/population.rst:224
msgid "Steady State Initialization"
msgstr "稳定状态初始化"

#: ../../source/behavior/equations/population.rst:226
msgid ""
"Let's imagine that these extreme swings in species population had some "
"undesirable ecological consequences.  In such a case, it would be useful to "
"understand what might reduce or even eliminate these fluctuations.  A simple"
" approach would be to keep the populations in a state of equilibrium.  But "
"how can we use these models to help use determine such a \"quiescent\" "
"state?"
msgstr ""
"让我们想象一下，这些物种种群的极端波动可能会导致一些不良的生态后果。\ "
"在这种情况下，理解减少或消除这些波动的方法对整改系统将会很有帮助。\ "
"一个简单的方法就是使两个种群维持在相对平衡的状态。\ "
"但是，如何使用这些模型来帮助我们确定这样的“稳定”状态？"

#: ../../source/behavior/equations/population.rst:233
msgid ""
"The answer lies in the initial conditions.  Instead of specifying an initial"
" population for both the predator and prey species, we might instead chose "
"to initialize the system with some other equations that somehow capture the "
"fact that the system is in equilibrium (you may remember this trick from the"
" ``FirstOrderSteady`` model :ref:`discussed previously "
"<ex_SimpleExample_FirstOrderSteady>`).  Fortunately, Modelica's approach to "
"initialization is rich enough to allow us to specify this (and many other) "
"useful types of initial conditions."
msgstr ""
"上述问题的答案就在于初始化条件。\ "
"我们可以用能描述系统处于平衡状态的方程来初始化系统\ "
"（相应的设置方法可以从\ :ref:`\ 前面讲述的\ "
"<ex_SimpleExample_FirstOrderSteady>`\ 实例\ ``FirstOrderSteady``\ 中获得），\ "
"而不是直接给猎食者和猎物种群指定初始值。\ "
"幸运的是，Modelica包含足够丰富的初始化方法，\ "
"允许我们指定上述（或者其他）类型的初始化条件。\ "

#: ../../source/behavior/equations/population.rst:242
msgid ""
"To ensure that our system starts in equilibrium, we simply need to define "
"what equilibrium is.  Mathematically speaking, the system is in equilibrium "
"if the following two conditions are met:"
msgstr ""
"为了确保我们的系统开始的时候处于平衡状态，我们只需要简单的定义什么是平衡。\ "
"从数学描述上来说，系统如果满足以下两个条件，就可以说该系统是处于平衡状态的："

#: ../../source/behavior/equations/population.rst:251
msgid ""
"To capture this in our Modelica model, all we need to do is use these "
"equations in our ``initial equation`` section, like this:"
msgstr "为了在Modelica模型中获取上述特征，我们只需在\ ``initial equation``\ 区域增加以下方程，如下所示："

#: ../../source/behavior/equations/population.rst:259
msgid ""
"The main difference between this and our previous model is the presence of "
"the highlighted initial equations.  Looking at this model, you might wonder "
"exactly what those initial equations mean.  After all, what we need to solve"
" for are ``x`` and ``y``.  But those variables don't even appear in our "
"initial equations.  So how are they solved for?"
msgstr ""
"上述模型和之前模型最大的区别就是包含突出显示的初始化方程。\ "
"回到上述模型，你可能想知道那些初始化方程到底意味着什么？毕竟，我们需要求解的是变量\ "
"``x``\ 和\ ``y``\ 。\ "
"但是这些变量甚至都没有出现在我们的初始化方程内。\ "
"系统是如何对这些变量求解的？"

#: ../../source/behavior/equations/population.rst:266
msgid ""
"The answer lies in understanding that the functions :math:`x(t)` and "
":math:`y(t)` are solved for by integrating the differential equations "
"starting from some initial equations.  During the simulation, we see that "
":math:`x` and :math:`\dot{x}` are \"coupled\" by the following equations:"
msgstr ""
"问题的答案在于理解函数\ :math:`x(t)`\ 和\ :math:`y(t)`\ "
"均是通过对带初始条件的微分方程进行积分来求解的。\ "
"在仿真过程中，我们可以看到\ :math:`x`\ 和\ :math:`\dot{x}`\ "
"是通过下面的方程进行“耦合”的："

#: ../../source/behavior/equations/population.rst:274
msgid ""
"(and, of course, a similar relationship exists between :math:`y` and "
":math:`\dot{y}`)"
msgstr "（当然了，在\ :math:`y`\ 和\ :math:`\dot{y}`\ 之间也存在着类似的关系）"

#: ../../source/behavior/equations/population.rst:277
msgid ""
"**However**, during initialization of the system (*i.e.*, when solving for "
"the initial conditions) this relationship doesn't hold.  So there is no "
"\"coupling\" between :math:`x` and :math:`\dot{x}` in that case (nor for "
":math:`y`: and :math:`\dot{y}`).  In other words, knowing :math:`x` or "
":math:`y` doesn't give you any clue as to how to compute :math:`\dot{x}` or"
" :math:`\dot{y}`.  The net result is that for the initialization problem we"
" can think of :math:`x`, :math:`y`, :math:`\dot{x}` and :math:`\dot{y}` as"
" four independent variables."
msgstr ""
"\ **但是**\ ，在系统初始化的过程中（即在计算初始条件时），上述关系是不成立的。\ "
"在这种情况下，\ :math:`x`\ 和\ :math:`\dot{x}`\ 之间并不存在“耦合”关系\ "
"（对\ :math:`y`:\ 和\ :math:`\dot{y}`\ 并不适用）。\ "
"换句话说，即便知道变量\ :math:`x`\ 和\ :math:`y`\ \ "
"是如何定义的也不能提供求解方程\ :math:`\dot{x}`\ 或\ :math:`\dot{y}`\ 的线索。\ "
"在初始化问题上，我们可以认为\ :math:`x`\ 、\ :math:`y`\ 、\ :math:`\dot{x}`\ \ "
"和\ :math:`\dot{y}`\ 是四个相互独立的变量。\ "

#: ../../source/behavior/equations/population.rst:286
msgid ""
"Said another way, while simulating, we solve for :math:`x` by integrating "
":math:`\dot{x}`.  So that integral equation is the equation used to solve "
"for :math:`x`.  But during initialization, we cannot use that equation so we"
" need an additional equation (for each integration that we would otherwise "
"perform during simulation)."
msgstr ""
"换一种说法，即在仿真的过程中，我们通过对\ :math:`\dot{x}`\ 进行积分来求解\ :math:`x`\ 。\ "
"因此，积分方程是用于求解\ :math:`x`\ 的方程。\ "
"但是在初始化过程中，我们不能用这个等式，\ "
"所以（对每个在仿真过程中求解的微分方程），我们需要一个额外的方程。\ "

#: ../../source/behavior/equations/population.rst:292
msgid ""
"In any case, the bottom line is that during initialization we require four "
"different equations to arrive at a unique solution.  In the case of our "
"``QuiescentModel``, those four equations are:"
msgstr ""
"任何情况下，我们要明白是在初始化过程中需要四个不同的方程来得到唯一解。\ "
"在我们的\ ``QuiescentModel``\ 模型中，这四个方程如下所示："

#: ../../source/behavior/equations/population.rst:303
msgid ""
"It is very important to understand that these equations **do not contradict "
"each other**.  Especially if you come from a programming background you "
"might look at the first two equations and think \"Well what is "
":math:`\dot{x}`?  Is it zero or is it :math:`x (\alpha - \beta y)`?\"  "
"The answer is **both**.  There is no reason that both equations cannot be "
"true!"
msgstr ""
"这些方程之间\ **并不相互矛盾**\ ，理解这一点非常重要。\ "
"如果你有编程背景，对前面两个方程可能会有疑问。\ "
"“到底\ :math:`\dot{x}`\ 取值是多少？\ "
"是零？还是\ :math:`x (\alpha - \beta y)`\ ？”\ "
"答案是\ **都是**\ 。\ "
"没有理由认为这两个方程不可能同时为真。\ "

#: ../../source/behavior/equations/population.rst:310
msgid ""
"The essential thing to remember here is that these are **equations not "
"assignment statements**.  The following system of equations is "
"mathematically identical and demonstrates more clearly how :math:`x` and "
":math:`y` could be solved:"
msgstr ""
"重要的是要记住，这些\ **方程不具备赋值语句的功能**\ 。\ "
"下面系统的方程与上述系统在数学表达上是完全一样的，并且清楚的展现了\ "
":math:`x`\ 和\ :math:`y`\ 是如何求解的："

#: ../../source/behavior/equations/population.rst:322
msgid ""
"In this form, it is a bit easier to recognize how we could arrive at values "
"of :math:`x` and :math:`y`.  The first thing to note is that we cannot solve"
" explicitly for :math:`x` and :math:`y`.  In other words, we cannot "
"rearrange these equations into the form :math:`x=...` without having "
":math:`x` also appear on the right hand side.  So we have to deal with the "
"fact that **this is a simultaneous system of equations** involving both "
":math:`x` and :math:`y`."
msgstr ""
"在这种格式下，我们更容易理解如何对\ :math:`x`\ 和\ :math:`y`\ 值进行求解。\ "
"首先要注意的是，我们不能显式求解变量\ "
":math:`x`\ 和\ :math:`y`\ 的值。\ "
"换句话说，如果没有变量\ :math:`x`\ "
"出现在等式的右边，我们就不能将这些方程的形式变换为\ :math:`x=...`\ 。\ "
"所以我们不得不接受，\ **这个方程组同时**\ "
"包含变量\ :math:`x`\ 和\ :math:`y`\ 。\ "

#: ../../source/behavior/equations/population.rst:330
msgid ""
"But the situation is further complicated by the fact that this system is "
"non-linear (which is precisely why we cannot use linear algebra to arrive at"
" a set of explicit equations).  In fact, if we study these equations "
"carefully we can spot the fact that there exist two potential solutions.  "
"One solution is trivial (:math:`x=0;y=0`) and the other is not."
msgstr ""
"但是，更加复杂的是该仿真系统是非线性的\ "
"（这也是为什么我们不能用线性代数将其变换为显式方程组）。\ "
"事实上，如果我们仔细研究这些方程，可以发现存在两种可能解。\ "
"一个解是平凡解（\ :math:`x=0;y=0`\ ），另一个则是非零解。\ "

#: ../../source/behavior/equations/population.rst:337
msgid ""
"So what happens if we try to simulate our ``QuiescentModel``?  The answer is"
" pretty obvious in the plot below:"
msgstr "如果我们试着仿真建立的\ ``QuiescentModel``\ 模型，会出现什么样的结果呢？仿真结果如下图所示："

#: ../../source/behavior/equations/population.rst:342
msgid ""
"We ended up with the trivial solution where the prey and predator "
"populations are zero.  In this case, we have no reproduction, predation or "
"starvation because all these effects are proportional to the populations "
"(*i.e.*, zero) so nothing changes.  But this isn't a very interesting "
"solution."
msgstr ""
"根据第一种解，猎食者和猎物的种群数都变为了零。\ "
"这种情况下系统没有繁殖、捕食以及饥饿。\ "
"因为上述影响因素都和物种种群数成比例，而物种种群数都为零。\ "
"所以系统没有变化。\ "
"但这并不是一个很有趣的解决方案。\ "

#: ../../source/behavior/equations/population.rst:348
msgid ""
"There are two solutions to this system of equations because it is non-"
"linear.  How can we steer the non-linear solver away from this trivial "
"solution?  If you were paying attention during the discussion of the :ref"
":`classic-lotka-volterra` model, then you've already been given a hint about"
" the answer."
msgstr ""
"因为该系统是非线性的，因此系统方程有两个解。\ "
"我们怎样才能使非线性求解器远离这个零根呢？如果你比较关注\ :ref:`classic-lotka-"
"volterra`\ 模型的讨论，那么已经给你了答案的暗示。\ "

#: ../../source/behavior/equations/population.rst:354
msgid ""
"Recall that the ``start`` attribute is overloaded.  During our discussion of"
" the :ref:`classic-lotka-volterra` model, it was pointed out that one of the"
" purposes of the ``start`` attribute was to provide an initial guess if the "
"variable with the ``start`` attribute was chosen as an iteration variable.  "
"Well, our ``QuiescentModel`` happens to be a case where ``x`` and ``y`` are,"
" in fact, iteration variables because they must be solved using a system of "
"non-linear equations.  This means that if we want to avoid the trivial "
"solution, we need to specify values for the ``start`` attribute on both "
"``x`` and ``y`` that are \"far away\" from the trivial solution we are "
"trying to avoid (or at least closer to the non-trivial solution we seek). "
"For example:"
msgstr ""
"还记得，前面提到过\ ``start``\ 属性是被重载了？在讨论\ :ref:`classic-lotka-volterra`\ "
"模型时，我们曾经指出，如果具有\ ``start``\ 属性的变量被选为迭代变量，\ ``start``\ "
"属性的其中一个作用是提供初始化猜想值。\ "
"在我们的\ ``QuiescentModel``\ 模型中，恰巧变量\ ``x``\ 和\ "
"``y``\ 就是迭代变量。\ "
"因为该变量必须通过系统的非线性方程组来求解。\ "
"这也就意味着，我们要对变量\ ``x``\ 和\ ``y``\ 的\ ``start``\ 属性值进行指定，\ "
"以尽量“避开”系统的零解（或者说至少接近我们期望的非零解）。\ "
"例如："

#: ../../source/behavior/equations/population.rst:372
msgid ""
"This model leads us to a set of initial conditions that is more inline with "
"what we were originally looking for (*i.e.*, one with non-zero populations "
"for both the predator and prey species)."
msgstr "上述模型引导我们设置一组初始条件，使得仿真结果更加符合我们最初的目标（即猎食者和猎物种群大小都得到了非零解）。\ "

#: ../../source/behavior/equations/population.rst:379
msgid ""
"It is worth pointing out (as we will do shortly in the section on :ref"
":`builtin-types`), that **the default value of the ``start`` attribute is "
"zero**.  This is why when we simulated our original ``QuiescentModel`` we "
"happened to land exactly on the trivial solution...because it was our "
"initial guess and it happened to be an exact solution so no other solution "
"or iterating was required."
msgstr ""
"值得指出的是（在\ :ref:`builtin-types`\ 章节中将会讨论），\ "
"\ ``start``\ \ **属性的默认值是零**\ 。\ "
"这也就是为什么当我们仿真\ ``QuiescentModel``\ 模型时，\ "
"我们会恰巧准确的得到了系统的零解。\ "
"因为这是我们初始的猜测，并且恰巧也是系统的精确解，\ "
"因此系统就无需进行迭代或求解其他根了。\ "

#: ../../source/behavior/equations/population.rst:389
msgid "Avoiding Repetition"
msgstr "避免重复"

#: ../../source/behavior/equations/population.rst:391
msgid ""
"We've already seen several different models (``ClassicModel``, "
"``QuiescentModel`` and ``QuiescentModelUsingStart``) based on the Lotka-"
"Volterra equations.  Have you noticed something they all have in common?  If"
" you look closely, you will see that they have almost **everything** in "
"common and that there are actually hardly any **differences** between them!"
msgstr ""
"基于猎食者猎物方程，\ "
"我们已经讨论过几个不同的模型\ "
"（\ ``ClassicModel``\ ，\ ``QuiescentModel``\ 以及\ ``QuiescentModelUsingStart``\ 模型）。\ "
"你有没有注意到这些模型间的共同点？如果你仔细观察，\ "
"你会发现它们几乎\ **所有的内容**\ 都相同。\ "
"实际上模型之间几乎没有任何\ **差别**\ ！"

#: ../../source/behavior/equations/population.rst:398
msgid ""
"In software engineering, there is a saying that \"Redundancy is the root of "
"all evil\".  Well the situation is no different here (in no small part "
"because Modelica code really is software).  The code we have written so far "
"would be very annoying to maintain.  This is because any bugs we found would"
" have to be fixed in each model. Furthermore, any improvements we made would"
" also have to be applied to each model.  So far, we are only dealing with a "
"relatively small number of models.  But this kind of \"copy and paste\" "
"approach to model development will result in a significant proliferation of "
"models with only slight differences between them."
msgstr ""
"在软件工程中，有一种说法是 \"冗余是一切罪恶的根源\" "
"。\ "
"这里的情况也不例外（其实很大程度上如此。\ "
"因为Modelica代码其实也是属于软件）。\ "
"目前为止，我们所写的代码维护起来将会特别恼人。\ "
"这是因为我们发现的任何错误都必须在每个模型中修改。\ "
"此外，我们所作的任何改进也必须应用到每一个模型上。\ "
"目前，我们处理的模型数量相对较少，但这种“复制粘贴”的模型开发方法会导致大量只有轻微差异的模型。\ "

#: ../../source/behavior/equations/population.rst:412
msgid ""
"So what can be done about this?  In object-oriented programming languages "
"there are basically two mechanisms that exist to reduce the amount of "
"redundant code.  They are *composition* (which we will address in the future"
" chapter on :ref:`components`) and *inheritance* which we will briefly "
"introduce here."
msgstr ""
"那么，我们能做些什么来避免上述情况的发生呢？在面向对象的编程语言中，基本上存在两种机制来减少冗余代码。\ "
"他们是\ *组合*\ （在后面的\ "
":ref:`components`\ 章节中进行讨论）和\ *继承*\ 。\ "
"这里我们只对继承进行简单的介绍。\ "

#: ../../source/behavior/equations/population.rst:418
msgid ""
"If we look closely at the ``QuiescentModelUsingStart`` example, we see that "
"there are almost no differences between it and our original ``ClassicModel``"
" version.  In fact, the only real differences are shown here:"
msgstr ""
"如果我们仔细观察\ ``QuiescentModelUsingStart``\ 模型，会发现和原来的\ ``ClassicModel``\ "
"模型之间几乎没有差别。\ "
"事实上，唯一的不同之处如下所示："

#: ../../source/behavior/equations/population.rst:434
msgid ""
"In other words, the only real difference is the addition of the ``initial "
"equation`` section (the original ``ClassicModel`` already contained non-zero"
" ``start`` values for our two variables, ``x`` and ``y``).  Ideally, we "
"could avoid having any redundant code by simply defining a model in terms of"
" the differences between it and another model.  As it turns out, this is "
"exactly what the ``extends`` keyword allows us to do.  Consider the "
"following alternative to the ``QuiescentModelUsingStart`` model:"
msgstr ""
"换句话说，唯一的区别是增加了\ ``initial equation``\ 区域（原始的\ ``ClassicModel``\ "
"模型已经包含了变量\ ``x``\ 和\ ``y``\ 的非零\ ``start``\ "
"属性值）。\ "
"理想情况下，我们可以通过简单的定义一个模型与另外模型间的差异，就可以由此避免任何冗余代码。\ "
"事实证明，这也正是\ ``extends``\ "
"关键字的作用。\ "
"考虑\ ``QuiescentModelUsingStart``\ 模型的以下版本："

#: ../../source/behavior/equations/population.rst:448
msgid ""
"Note the presence of the ``extends`` keyword.  Conceptually, this \"extends "
"clause\" simply asks the compiler to insert the contents of another model "
"(``ClassicModel`` in this case) into the model being defined.  In this way, "
"we copy (or \"inherit\") everything from ``ClassicModel`` without having to "
"repeat its contents.  As a result, the ``QuiescentModelWithInheritance`` is "
"the same as the ``ClassicModel`` with an additional set of initial equations"
" inserted."
msgstr ""
"注意\ ``extends``\ 关键字的使用。\ "
"从概念上讲，“扩展子句”只是简单的要求编译器将另外的模型（本例是\ "
"``ClassicModel``\ 模型）插入到所定义的模型中。\ "
"通过这种方式，我们将从\ ``ClassicModel``\ "
"模型中复制（或“继承”）其包含的所有内容，而无需重复定义。\ "
"因此，除了新加入的初始化方程外，\ "
"``QuiescentModelWithInheritance``\ 模型和\ ``ClassicModel``\ 模型其他部分完全一样。\ "

#: ../../source/behavior/equations/population.rst:458
msgid ""
"But what about a case where we don't want **exactly** what is in the model "
"we are inheriting from?  For example, what if we wanted to change the values"
" of the ``gamma`` and ``delta`` parameters?"
msgstr ""
"但是，有一种情况，如果我们不想\ **完全精确**\ 地继承模型中的内容，该怎么办？\ "
"例如，如果我们想要改变参数\ ``gamma``\ 和\ ``delta``\ 的值？"

#: ../../source/behavior/equations/population.rst:462
msgid ""
"Modelica handles this by allowing us to include a set of \"modifications\" "
"when we use ``extends``.  These modifications come after the name of the "
"model being inherited from as shown below:"
msgstr ""
"当使用\ ``extends``\ "
"功能时，Modelica语言允许我们对模型加入相应的“修改语句”。\ "
"模型对应的修改语句紧跟在所继承模型的名字后面，如下所示："

#: ../../source/behavior/equations/population.rst:471
msgid ""
"Also note that we could have inherited from ``ClassicModel``, but then we "
"would have had to repeat the initial equations in order to have quiescent "
"initial conditions.  But by instead inheriting from "
"``QuiescentModelWithModifications``, we reuse the content from **two** "
"different models and avoid repeating ourselves even once."
msgstr ""
"还要注意的是，我们可以从\ ``ClassicModel``\ "
"中继承。\ "
"但是，随后我们还必须重新定义初始化方程组以获得静止的初始条件。\ "
"但是，我们不是通过继承\ ``QuiescentModelWithModifications``\ 模型，\ "
"而是通过重复使用\ **两个**\ 不同模型的内容来避免重复。\ "

#: ../../source/behavior/equations/population.rst:0
msgid "More population dynamics"
msgstr "更多的种群动态"

#: ../../source/behavior/equations/population.rst:479
msgid ""
"This concludes the set of examples for this chapter.  If you'd like to "
"explore the Lotka-Volterra equations in greater depth, an upcoming section "
"titled :ref:`population-components` demonstrates how to build complex models"
" of population dynamics using graphical components that are dropped onto a "
"schematic and connected together."
msgstr ""
"这就是本章所包含的所有实例。\ "
"如果你想更深入的探索猎食者猎物方程，在下面\ :ref:`population-components`\ "
"章节中将会重新讲述如何通过示意图并连接在一起的图形化组件来构建复杂的种群动态模型。\ "

#: ../../source/behavior/equations/population.rst:485
msgid ""
"Lotka, A.J., \"Contribution to the Theory of Periodic Reaction\", J. Phys. "
"Chem., 14 (3), pp 271–274 (1910)"
msgstr ""

#: ../../source/behavior/equations/population.rst:486
msgid ""
"Volterra, V., Variations and fluctuations of the number of individuals in "
"animal species living together in Animal Ecology, Chapman, R.N. (ed), "
"McGraw–Hill, (1931)"
msgstr ""

#: ../../source/behavior/equations/population.rst:487
msgid ""
"C.M. Guldberg and P. Waage,\"Studies Concerning Affinity\" C. M. "
"Forhandlinger: Videnskabs-Selskabet i Christiana (1864), 35"
msgstr ""

#: ../../source/behavior/equations/population.rst:58
msgid ""
"Finally, the last effect we need to consider is \"predation\", *i.e.*, the "
"consumption of the prey species by the predator species.  Without predators,"
" the prey species would (at least mathematically) grow exponentially.  So "
"predation is the effect that keeps the prey species population in check.  "
"Similarly, without any prey, the predator species would simply die off.  So "
"predation is what balances out this effect and keeps the predator population"
" from going to zero.  Again, we have a proportionality relationship.  But "
"this time, it is actually a bilinear relationship that is, again, "
"conceptually similar to the Law of Mass Action.  This relationship is simply"
" capturing, mathematically, the fact that the chance that a predator will "
"find and consume some prey is proportional to both the population of the "
"prey and the predators.  Since this particular effect requires both species "
"to be involved, this mathematical relationship has a slightly different "
"structure than reproduction and starvation, *i.e.,*"
msgstr ""
"最后一个我们要考虑的因素是“捕食”，即猎食者对猎物的消耗。\ "
"如果没有天敌，猎物会指数增长（至少从数学观点）。\ "
"因此，捕食是保持猎物种群的重要因素。\ "
"同样的，没有猎物，猎食者也会全部死光。\ "
"因此，捕食平衡了这种效应，并且防止猎食者种群的消失。\ "
"再次的，我们得到一个比例关系。\ "
"但是，这个比例关系实际上是一个双线性关系。\ "
"而且，概念上也类似于质量作用定律。\ "
"这种比例关系在数学上很容易得到。\ "
"事实上，猎食者发现并捕获猎物的机会与猎物种群、猎食者种群两者都存在着正比关系。\ "
"由于这种特殊的影响因素，需要两个物种都参与。\ "
"因此，这里的数学表达式与前述的繁殖率及猎食者饥饿程度的公式都在结构上有所不同，即："

#: ../../source/behavior/equations/population.rst:154
msgid ""
"One way to avoid both of these disadvantages is to use the ``fixed`` "
"attribute (also discussed in the section on :ref:`builtin-types`). The "
"``fixed`` attribute can be used to tell the compiler that the start "
"attribute **must** be used as an initial condition.  In other words, an "
"``initial equation`` like this:"
msgstr ""
"避免上述缺点我们可以使用\ ``fixed``\ 属性（在\ :ref:`builtin-types`\ 章节中作进一步讨论）。\ "
"变量的\ ``fixed``\ 属性被用来通知编译器\ ``start``\ 属性必须作为初始条件来使用。\ "
"换句话说，如下的\ ``initial equation``\ 部分："

#: ../../source/behavior/equations/population.rst:166
msgid ""
"is equivalent to the following declaration utilizing the ``start`` and "
"``fixed`` attributes:"
msgstr "等同于下述变量声明中关于\ ``fixed``\ 和\ ``start``\ 属性的使用："

#: ../../source/behavior/equations/population.rst:173
msgid ""
"Finally, one additional complication is that the ``start`` attribute is also"
" \"overloaded\".  This means that it is actually used for two different "
"things.  If the variable in question is not a state, but is instead an "
"\"iteration variable\" (*i.e.*, a variable whose solution depends on a non-"
"linear system of equations), then the ``start`` attribute may be used by a "
"Modelica compiler as an initial guess (*i.e.*, the value used for the "
"variable during the initial iteration of the non-linear solver)."
msgstr ""
"最后，\ ``start``\ "
"属性的另一个复杂之处是其功能被“重载”了。\ "
"这就意味着，此属性有两种不同的用途。\ "
"如果，所讨论的变量不是一个状态，而是一个“迭代变量”（即变量的解依赖于非线性方程组），\ "
"那么\ ``start``\ 属性可以通过编译器作为初始的猜测值\ "
"（即非线性求解方程首次迭代时使用的变量值）。\ "
