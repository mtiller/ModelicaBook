#
msgid ""
msgstr ""
"Project-Id-Version: Modelica by Example 0.2.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-04-14 10:14-0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/behavior/functions/polynomial.rst:4
msgid "Polynomial Evaluation"
msgstr "多项式计算"

#: ../../source/behavior/functions/polynomial.rst:6
msgid ""
"Our first example will center around using functions to evaluate "
"polynomials.  This will help use understand the basics of defining and using"
" functions."
msgstr "我们的第一个例子将以使用函数计算多项式为中心。\ "
"这将帮助我们理解函数定义和使用的基础知识。\ "

#: ../../source/behavior/functions/polynomial.rst:11
msgid "Computing a Line"
msgstr "计算直线"

#: ../../source/behavior/functions/polynomial.rst:14
msgid "Mathematical Background"
msgstr "数学背景"

#: ../../source/behavior/functions/polynomial.rst:16
msgid ""
"Before diving until polynomials of arbitrary order, let's first consider how"
" we could use a function to evaluate points on a line. Mathematically, what "
"we'd like to define is a function that is applied as follows:"
msgstr "在能处理任意阶多项式之前，让我们首先思考一下我们如何使用函数计算一条直线上的点。\ "
"在数学上，我们想定义一个如下所示的函数："

#: ../../source/behavior/functions/polynomial.rst:25
msgid ""
"where :math:`x` is the independent variable, :math:`(x_0,y_0)` is one point "
"that defines the line and :math:`(x_1,y_1)` is the other point that defines "
"the line.  Mathematically, such a function could be defined as follows:"
msgstr ""
"其中\ :math:`x`\ 是自变量，\ :math:`(x_0,y_0)`\ 是定义直线的一个点，\ "
":math:`(x_1,y_1)`\ 是定义直线的另一个点。\ "
"数学上，这种函数可以被定义为如下形式："

#: ../../source/behavior/functions/polynomial.rst:34
msgid ""
"To reduce the number of arguments, let's assume that combine :math:`x_0` and"
" :math:`y_0` into a single point represented by the vector "
":math:`\vec{p_0}` and we combine :math:`x_1` and :math:`y_1` into a single "
"point represented by the vector :math:`\vec{p_1}` so that the function is "
"now invoked as:"
msgstr ""
"为了减少参数数量，让我们假设\ :math:`x_0`\ 和\ :math:`y_0`\ 代表一个单一的点，以矢量\ "
":math:`\vec{p_0}`\ 表示，\ :math:`x_1`\ 和\ :math:`y_1`\ 代表另一个单一的点，以矢量\ "
":math:`\vec{p_1}`\ 表示，因此现在函数调用如如下所示："

#: ../../source/behavior/functions/polynomial.rst:45
msgid "Modelica Representation"
msgstr "Modelica描述"

#: ../../source/behavior/functions/polynomial.rst:47
msgid ""
"The question now is how can we transform this mathematical relationship into"
" a function that we can invoke from within a Modelica model.  To do this, we"
" must define a new Modelica function."
msgstr "现在的问题是我们如何将这种数学关系转换为可以在Modelica模型中调用的函数。\ "
"为了做到这一点，我们必须定义一个新的Modelica函数。\ "

#: ../../source/behavior/functions/polynomial.rst:51
msgid ""
"It turns out that a function definition is very similar (syntactically, at "
"least) to a :ref:`model-definition`.  Here is the definition of our ``Line``"
" function in Modelica:"
msgstr ""
"事实证明函数定义与模型定义\ :ref:`model-definition`\ "
"非常相似（至少在语法层面）。\ "
"这里我们展示的是在Modelica中定义的\ ``Line``\ 函数："

#: ../../source/behavior/functions/polynomial.rst:63
msgid ""
"All the arguments to the function are prefixed with the ``input`` qualifier."
"  The result of the function has the ``output`` qualifier. The body of the "
"function is an ``algorithm`` section.  The value for the return value (``y``"
" in this case) is computed by the ``algorithm`` section."
msgstr ""
"函数的所有输入参数均以\ ``input``\ 限定词作为前缀。\ "
"函数的输出结果以\ ``output``\ 限定词作为前缀。\ "
"函数主体为\ "
"``algorithm``\ 区域。\ "
"返回值（本例中是\ ``y``\ ）通过\ ``algorithm``\ 区域计算得到。\ "

#: ../../source/behavior/functions/polynomial.rst:69
msgid ""
"So in this case, the ``output`` value, ``y``, is computed in terms of the "
"``input`` values ``x``, ``p0`` and ``p1``.  Note that there is no ``return``"
" statement in this function.  Whatever the value of the ``output`` variable "
"is at the conclusion of the ``algorithm`` section is automatically the value"
" returned."
msgstr ""
"所以在本例中，\ ``output``\ 值\ ``y``\ 是根据\ ``input``\ 值\ ``x``\ 、\ "
"``p0``\ 、\ ``p1``\ 计算得到。\ "
"注意，此函数中没有\ ``return``\ 语句。\ "
"函数将自动返回\ "
"``algorithm``\ 区域计算得到的\ ``output``\ 变量的结果。\ "

#: ../../source/behavior/functions/polynomial.rst:75
msgid ""
"A couple of things to note that were discussed in previous chapters. First, "
"note the descriptive strings on both the function itself and the arguments."
"  These are very useful in documenting the purpose of the function and its "
"arguments.  Also note how the points use arrays to represent a two-"
"dimensional vector and how those arrays are indexed in this example."
msgstr ""
"有几个在前面几章已经讨论过的事情需要注意。\ "
"首先，注意函数本身和参数的说明字符串。\ "
"它们在记录函数和参数的用法方面很有意义。\ "
"同时需要注意如何使用数组来表达一个二维向量和这些数组在本例中是如何索引的。\ "

#: ../../source/behavior/functions/polynomial.rst:82
msgid ""
"One troubling aspect of the ``Line`` model is the length and complexity of "
"the expression used to compute ``y``.  It would be nice if we could break "
"that expression down."
msgstr "\ ``Line``\ 模型唯一不足之处在于计算\ ``y``\ 表达式的长度以及复杂性。\ "
"如果我们可以拆分表达式，就能改善这种不足。\ "

#: ../../source/behavior/functions/polynomial.rst:87
msgid "Intermediate Variables"
msgstr "中间变量"

#: ../../source/behavior/functions/polynomial.rst:89
msgid ""
"In order to simplify the expression for ``y``, we need to introduce some "
"intermediate variables.  We can already see that ``x``, ``p0`` and ``p1`` "
"are variables that we can use from within the function. We'd like to "
"introduce additional variables, but they shouldn't be arguments.  Instead, "
"their values should be computed \"internally\" to the function.  To achieve "
"this, we create a collection of variables that are ``protected``.  Such "
"variables are assumed to be computed internally by the function.  Here is an"
" example that uses ``protected`` to declare and compute two internal "
"variables:"
msgstr ""
"为了简化\ ``y``\ 的表达式，我们需要引入一些中间变量。\ "
"我们已经看到\ ``x``\ ，\ ``p0``\ ，\ ``p1``\ "
"是我们可以在函数中使用的变量。\ "
"我们想引入额外的变量。\ "
"但是，同时这些变量也不应是参数。\ "
"换句话说，引入的变量值必须在函数“内部”进行计算。\ "
"为了实现这个目标，我们创建了一个受保护（\"
" ``protected``\ ）变量的集合。\ "
"这些变量可认为是在函数内部计算得到的。\ "
"下面的例子展示了使用\ ``protected``\ "
"来声明和计算两个内部变量："

#: ../../source/behavior/functions/polynomial.rst:104
msgid ""
"This model introduces two new variables.  One variable, ``m``, represents "
"the slope of the line and the other, ``b``, represents the return value for "
"the condition when ``x=0``.  Having computed these two intermediate "
"variables, the expression to evaluate ``y`` becomes the more easily "
"recognized form ``y := m*x+b``."
msgstr ""
"此模型引入了两个新变量。\ "
"其中一个变量\ ``m``\ 代表了直线的斜率。\ "
"另一个变量\ ``b``\ 代表了当条件为\ ``x=0``\ "
"时的返回值。\ "
"通过计算这两个中间变量，使得计算\ ``y``\ 的表达式变成了非常容易识别的形式：\ ``y := m*x+b``\ 。\ "

#: ../../source/behavior/functions/polynomial.rst:111
msgid "Computing a Polynomial"
msgstr "计算多项式结果"

#: ../../source/behavior/functions/polynomial.rst:114
msgid "Mathematical Definition"
msgstr "数学定义"

#: ../../source/behavior/functions/polynomial.rst:116
msgid ""
"Of course, our goal for this section is to create a function that can "
"compute arbitrary polynomials.  So now that we've seen a few basic "
"functions, let us proceed with our ultimate goal.  We will formulate a "
"function that is invoked as follows:"
msgstr ""
"当然，本节我们的目标是创建一个函数，以此计算任意的多项式。\ "
"到目前为止，我们已经看到了一些基本的函数。\ "
"在此基础上让我们继续朝着最终目标前进。\ "
"我们会构建一个函数，其调用方式如下："

#: ../../source/behavior/functions/polynomial.rst:125
msgid ""
"where :math:`x` is again the independent variable and :math:`\vec{c}` is a "
"vector of coefficients such that our polynomial is evaluated as:"
msgstr "其中，\ :math:`x`\ 依然代表独立变量。\ "
"\ :math:`\vec{c}`\ 代表系数组成的向量。\ "
"这样我们的多项式以如下方式计算："

#: ../../source/behavior/functions/polynomial.rst:132
msgid ""
"where ``N`` is the number of coefficients passed to the function. There are "
"two important things to note at this point.  First, **the first element in**"
" :math:`\vec{c}` **corresponds to the highest order term in the "
"polynomial**.  Second, we are using a notation that assumes that the "
"elements in :math:`\vec{c}` are numbered **starting from 1** to make the "
"transition to Modelica code (where arrays are indexed starting from 1) "
"easier."
msgstr ""
"其中，\ ``N``\ 是传递给函数的系数的个数。\ "
"在这一点上有两件重要的事情需要注意。\ "
"首先，\ :math:`\vec{c}`\ "
"**的第一个元素对应于多项式中的最高阶次项**\ 。\ "
"然后，我们通过使用符号并假设\ :math:`\vec{c}`\ 的元素\ "
"**从1开始编号**\ 。\ "
"以此使函数能更容易地转化为Modelica代码（其数组索引从1开始）。\ "

#: ../../source/behavior/functions/polynomial.rst:140
msgid ""
"Note that the definition for :math:`p` above is easy to read and understand."
"  But when working with floating point numbers with finite precision, it is "
"more efficient and more accurate to use a recursive approach for evaluating "
"the polynomial.  For a :math:`4^{th}` order polynomial, the evaluation would"
" be:"
msgstr ""
"注意，上文中\ :math:`p`\ "
"的定义非常容易阅读和理解。\ "
"但是在处理有限精度的浮点数时，使用递归的方法来计算多项式会更高效和更精确。\ "
"对于一个\ :math:`4`\ "
"阶多项式，其表达式为："

#: ../../source/behavior/functions/polynomial.rst:150
msgid ""
"This is more efficient because it relies on simple multiplication and "
"addition operations and avoids performing exponentiation operations, which "
"are more expensive,  It is more accurate because exponentiation can easily "
"trigger round-off or truncation errors in finite precision floating point "
"representations."
msgstr ""
"这种方法相对高效，因为它仅用到了简单的乘法和加法操作，避免了处理更复杂的求幂运算。\ "
"同时，这种方法更为精确。\ "
"因为使用有限精度浮点表示形式时，求幂运算更容易引发舍入误差和截尾误差。\ "

#: ../../source/behavior/functions/polynomial.rst:157
msgid "Modelica Definition"
msgstr "Modelica定义"

#: ../../source/behavior/functions/polynomial.rst:159
msgid ""
"Now that we've defined precisely what computations we want the function to "
"perform, we are just left with the task of defining the function in "
"Modelica.  In this case, our polynomial evaluation function can be "
"represented in Modelica as:"
msgstr ""
"到目前为止，我们已经精确定义了我们希望函数执行的计算方法。\ "
"剩下的工作只是在Modelica中定义函数。\ "
"本例中，我们的多项式计算函数在Modelica中描述如下："

#: ../../source/behavior/functions/polynomial.rst:168
msgid ""
"Again, all the arguments to the function have the ``input`` qualifier and "
"the return value has the ``output`` qualifier.  As with the previous "
"example, we've defined an intermediate variable, ``n``, as a convenient way "
"to refer to the length of the coefficient vector.  We also see how a ``for``"
" loop can be used to represent the recursive evaluation of our polynomial "
"for any arbitrary order."
msgstr ""
"回顾一下，函数所有的（输入）参数都有\ ``input``\ 限定词，返回值都有\ ``output``\ "
"限定词。\ "
"与前面的例子一样，我们定义了一个中间变量\ ``n``\ ，以此提供一种简便的方法去查阅系数向量的长度。\ "
"本例中，我们也展示了如何使用一个\"
" ``for``\ 循环来描述任意阶数的多项式的递归计算。\ "

#: ../../source/behavior/functions/polynomial.rst:175
msgid ""
"To verify that this function is working properly, let's use it in a model.  "
"Consider the following Modelica model:"
msgstr "让我们通过在模型中使用这个函数，以此验证其正确性。\ "
"使用的Modelica模型如下："

#: ../../source/behavior/functions/polynomial.rst:182
msgid ""
"Remember that the first element in ``c`` corresponds to the highest order "
"term.  If we compare a direct evaluation of the polynomial, ``yp``, with one"
" computed by our function, ``yf``, we see they are identical:"
msgstr ""
"记住，\ ``c``\ 的第一个元素对应最高阶项。\ "
"如果我们把多项式的直接计算结果\ ``yp``\ 和使用我们函数计算的结果\ "
"``yf``\ 作对比，我们发现计算结果相等："

#: ../../source/behavior/functions/polynomial.rst:190
msgid "Differentiation"
msgstr "微分"

#: ../../source/behavior/functions/polynomial.rst:192
msgid ""
"It is completely plausible that this polynomial evaluation might be used to "
"represent a quantity that was ultimately differentiated by the Modelica "
"compiler.  The following examples is admittedly contrived, but it "
"demonstrates how such a polynomial might come to be differentiated in a "
"model:"
msgstr ""
"这个多项式所计算的量完全可能最终被Modelica编译器求微分。\ "
"下面的例子虽然有些牵强，但是它展示了一个多项式在什么情况下会在一个模型中被微分："

#: ../../source/behavior/functions/polynomial.rst:202
msgid ""
"Here we have the same equations for ``yf``, evaluated using ``Polynomial``, "
"and ``yp``, evaluated directly as a polynomial.  But we've added two "
"additional variables, ``d_yf`` and ``d_yp`` representing the derivative of "
"``yf`` and ``yp``, respectively.  If we attempt to compile this model the "
"compiler is very likely to throw an error related to the equation for "
"``d_yf``.  The reason is that it has no way to compute the derivative of "
"``yf``.  This is because, unlike ``yp`` which is computed with a simple "
"expression, we've hidden the details of how ``yf`` is computed behind the "
"function ``Polynomial``. In general, Modelica tools do not look at the "
"implementations of functions to compute derivatives and, even if they did, "
"determining the derivative of an arbitrary algorithm is not an easy thing to"
" do."
msgstr ""
"本例中我们使用了与上述例子相同的\ ``yf``\ 和\ ``yp``\ 方程。\ "
"\ ``yf``\ 使用\ "
"``Polynomial``\ 计算，\ ``yp``\ 直接使用多项式计算。\ "
"我们还额外添加了两个变量，\ ``d_yf``\ 和\ "
"``d_yp``\ 。\ "
"它们分别代表\ ``yf``\ 和\ ``yp``\ 的导数。\ "
"如果我们尝试编译此模型，编译器很有可能会引发一个关于\ "
"``d_yf``\ 方程的错误。\ "
"其原因是编译器无法计算\ ``yf``\ 的导数。\ "
"这是因为与通过简单表达式计算的\ ``yp``\ "
"不同，我们在\ ``Polynomial``\ 函数的背后隐藏了计算\ ``yf``\ "
"的细节。\ "
"通常来说，Modelica工具不会从函数实现推导其导数。\ "
"即使编译器做到了这点，如何确定任意算法的导数依然很不容易。\ "

#: ../../source/behavior/functions/polynomial.rst:219
msgid ""
"So the next question is how can we deal with this situation?  Won't this "
"make it difficult to use our functions within models? Fortunately, Modelica "
"gives us a way to specify how to evaluate the derivative of a function.  "
"This is done by adding something called an ``annotation`` to the function "
"definition."
msgstr ""
"因此，接下来的问题就是我们应如何处理这种情况？这不会使得在函数在模型中变得难以使用吗？幸运的是，Modelica给我们提供了一个方法来指定函数导数的计算。\ "
"这就是通过在函数定义时添加一种叫做\"
" ``annotation``\ 的语句来实现的。\ "

#: ../../source/behavior/functions/polynomial.rst:0
msgid "Annotations"
msgstr "标注"

#: ../../source/behavior/functions/polynomial.rst:227
msgid ""
"An annotation is a piece of metadata that doesn't describe the behavior of "
"the function directly (*i.e.,* it doesn't affect the value the function "
"returns).  Instead, annotations are used by Modelica compilers to give them "
"\"hints\" about how to deal with certain situations.  Annotations are always"
" \"optional\" information which means tools are not required to use the "
"information when provided.  The Modelica specification defines a number of "
"standard annotations so that they are interpreted consistently across "
"Modelica tools."
msgstr ""
"标注（annotation）是一段元数据。\ "
"它不直接描述函数的行为（也就是说它不影响函数的返回值）。\ "
"然而，Modelica编译器会使用标注以得到“提示”，以此知道如何处理某些特定的情况。\ "
"标注语句通常是“可选”的信息。\ "
"这就意味着即使提供了标注，工具也不会被强制要求使用这些信息。\ "
"Modelica语义定义了许多标准的标注语句，以便Modelica工具能直接解析。\ "

#: ../../source/behavior/functions/polynomial.rst:237
msgid ""
"In this case, what we need is the ``derivative`` annotation because it will "
"allow us to communicate information to the Modelica compiler on how to "
"evaluate the derivative of our function.  To do this, we define a new "
"evaluation function, ``PolynomialWithDerivative``, as follows:"
msgstr ""
"在本例中，我们需要\ ``derivative``\ "
"标注。\ "
"因为此标注可以让我们告诉Modelica编译器如何计算函数的导数。\ "
"为了实现这一点，我们定义了一个新函数，\ "
"``PolynomialWithDerivative``\ 用于计算，如下所示："

#: ../../source/behavior/functions/polynomial.rst:247
msgid ""
"Note that this function is identical except for the highlighted line. In "
"other words, all we needed to do was add the line:"
msgstr "注意，这个函数除了高亮显示的行以外，与之前的函数是一致的。\ "
"换句话说，我们只需要把这行代码添加到我们的函数中："

#: ../../source/behavior/functions/polynomial.rst:254
msgid ""
"to our function in order to explain to the Modelica compiler how to evaluate"
" the derivative of this function.  What it indicates is that the function "
"``PolynomialFirstDerivative`` should be used to evaluate the derivative of "
"``PolynomialWithDerivative``."
msgstr ""
"我们通过在函数内添加这行代码以此向Modelica编译器解释如何计算这个函数的导数。\ "
"这行代码的含义是函数\ "
"``PolynomialFirstDerivative``\ 应该用于计算\ ``PolynomialWithDerivative``\ 的导数。\ "

#: ../../source/behavior/functions/polynomial.rst:259
msgid ""
"Before discussing the implementation of the ``PolynomialFirstDerivative`` "
"function, let's first understand, mathematically, what is required.  Recall "
"our original definition of our polynomial interpolation function:"
msgstr ""
"在讨论函数\ ``PolynomialFirstDerivative``\ "
"的执行之前，我们首先要从数学角度明白什么是必需的。\ "
"回忆我们之前定义的多项式插值函数："

#: ../../source/behavior/functions/polynomial.rst:268
msgid ""
"Note that :math:`p` takes two arguments.  If we wish to differentiate "
":math:`p` by some arbitrary variable :math:`z`, we can use the chain rule to"
" express the total derivative of :math:`p` with respect to :math:`z` as:"
msgstr ""
"注意\ :math:`p`\ 有两个参数。\ "
"如果我们希望\ :math:`p`\ 对任意的变量\ :math:`z`\ "
"求导，我们可以使用链式法则来表示\ :math:`p`\ 对\ :math:`z`\ 的全微分，如下所示："

#: ../../source/behavior/functions/polynomial.rst:280
msgid ""
"We can derive the following relations from our original definition of "
":math:`p`.  First, for the partial derivative of :math:`p` with respect to "
":math:`x` we get:"
msgstr "我们可以从最初\ :math:`p`\ 的定义中导出如下关系。\ "
"首先，对于\ :math:`p`\ 对\ :math:`x`\ 的偏导数，我们可以得到："

#: ../../source/behavior/functions/polynomial.rst:288
msgid "where :math:`c'` is defined as:"
msgstr "其中\ :math:`c'`\ 定义如下："

#: ../../source/behavior/functions/polynomial.rst:294
msgid ""
"Second, for the partial derivative of :math:`p` with respect to "
":math:`\vec{c}` we get:"
msgstr "其次，对于\ :math:`p`\ 对\ :math:`\vec{c}`\ 的偏导数，我们可以得到："

#: ../../source/behavior/functions/polynomial.rst:301
msgid ""
"where the **vector** :math:`\vec{d_i}` is the :math:`i^{th}` column of an "
":math:`NxN` identity matrix."
msgstr "其中\ **向量**\ \ :math:`\vec{d_i}`\ 是\ :math:`NxN`\ 的单位矩阵的第\ :math:`i`\ 列。\ "

#: ../../source/behavior/functions/polynomial.rst:316
msgid "such that:"
msgstr "因此："

#: ../../source/behavior/functions/polynomial.rst:324
msgid ""
"For this reason, the ``derivative`` annotation should point to a function "
"that takes the same arguments as :math:`df`.  In our case, that function, "
"``PolynomialFirstDerivative`` would be defined as follows:"
msgstr ""
"为此，\ ``derivative``\ 标注必须指定一个与\ :math:`df`\ 参数相同的函数。\ "
"在我们的例子中，函数\ ``PolynomialFirstDerivative``\ 将被定义为如下形式："

#: ../../source/behavior/functions/polynomial.rst:333
msgid ""
"Note how the arguments of our original function are repeated to create twice"
" as many arguments (as we would expect).  The second set of arguments "
"represent the :math:`\frac{\mathrm{d}x}{\mathrm{d}z}` and "
":math:`\frac{\mathrm{d}\vec{c}}{\mathrm{d}z}` quantities, respectively."
"  Note that the assumption is that :math:`z` is a scalar so the types of the"
" input arguments are the same.  Exploiting our knowledge about the partial "
"derivatives of a polynomial, the calculation of the derivatives is done by "
"leveraging our polynomial evaluation function."
msgstr ""
"请注意我们最初函数的参数如何被复制变成（预期数量的）两倍那么多。\ "
"第二组参数分别代表了\ :math:`\frac{\mathrm{d}x}{\mathrm{d}z}`\ 和\ "
":math:`\frac{\mathrm{d}\vec{c}}{\mathrm{d}z}`\ 这些量。\ "
"注意，这里假设\ :math:`z`\ 是一个标量。\ "
"因此输入参数的类型是相同的。\ "
"利用我们关于多项式的偏导数的知识，导数的计算就可通过同一个多项式计算函数来完成。\ "

#: ../../source/behavior/functions/polynomial.rst:343
msgid "We can exercise all of these functions using the following model:"
msgstr "我们可以通过以下的模型来使用所有的这些函数："

#: ../../source/behavior/functions/polynomial.rst:349
msgid ""
"Simulating this model and comparing results, we see agreement between ``yf``"
" and ``yp`` as well as ``d_yf`` and ``d_yp``:"
msgstr ""
"对这个模型进行仿真并且比较结果，\ "
"我们看到参数\ ``yf``\ 和\ ``yp``\ 的对比结果，以及\ ``d_yf``\ 和\ ``d_yp``\ 的对比结果，如下："

#: ../../source/behavior/functions/polynomial.rst:304
msgid ""
"It turns out that for efficiency reasons, it is better for the Modelica "
"compiler to give us :math:`\frac{\mathrm{d}x}{\mathrm{d}z}` and "
":math:`\frac{\mathrm{d}\vec{c}}{\mathrm{d}z}` than to provide functions "
"to evaluate :math:`\frac{\partial p}{\partial x}` and "
":math:`\frac{\partial p}{\partial c_i}`.  So, mathematically speaking, "
"what the Modelica compiler needs is a new function that is invoked with the "
"following arguments:"
msgstr ""
"事实表明，出于效率的原因，Modelica编译器应提供\ :math:`\frac{\mathrm{d}x}{\mathrm{d}z}`\ "
"和\ :math:`\frac{\mathrm{d}\vec{c}}{\mathrm{d}z}`\ ，\ "
"而不应该提供函数去计算\ :math:`\frac{\partial p}{\partial x}`\ 和\ :math:`\frac{\partial "
"p}{\partial c_i}`\ 的函数。\ "
"因此从数学角度来说，Modelica编译器需要的是一个可以用以下参数进行调用的新函数："
