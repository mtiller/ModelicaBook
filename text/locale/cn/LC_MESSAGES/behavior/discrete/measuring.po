#
msgid ""
msgstr ""
"Project-Id-Version: Modelica by Example 0.2.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-04-14 10:14-0400\n"
"PO-Revision-Date: 2014-10-09 12:00+0100\n"
"Last-Translator: Dongping Xie <dongping.xie.tud@gmail.com>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/behavior/discrete/measuring.rst:5
msgid "Speed Measurement"
msgstr "速度的测量"

#: ../../source/behavior/discrete/measuring.rst:8
msgid "Baseline System"
msgstr "基准系统"

#: ../../source/behavior/discrete/measuring.rst:10
msgid ""
"There are many applications where we need to model the interaction between "
"continuous behavior and discrete behavior.  For this section, we'll look at "
"techniques used to measure the speed of a rotating shaft.  For our "
"discussion here, we will reuse the :ref:`mechanical example <mech-example>` "
"we discussed previously in our discussion of :ref:`basic-equations`:"
msgstr ""
"在许多应用中，我们需要对连续行为与离散行为之间的相互作用进行建模。\ "
"在本节中，我们将看到用于测量旋转轴速度的技术。\ "
"在这里的讨论里，我们将重用前面在\\ "
":ref:`basic-equations`\\ 中讨论过的\\ :ref:`\\ 机械中的例子 <mech-example>`\\ 。\ "

#: ../../source/behavior/discrete/measuring.rst:23
msgid ""
"We will reuse this model by adding an ``extends`` clause to our model.  This"
" essentially imports everything from the model we are extending from.  We'll"
" talk more about the ``extends`` clause later when we discuss "
":ref:`packages`.  For now, just think of it as copying the contents of "
"another model into the current model."
msgstr ""
"我们将在新模型中增加一个\\ ``extends``\\ （扩展）条款，以重用旧的模型。\ "
"这个语句实质上是导入被扩展模型的一切内容。\ "
"我们将在之后讨论\\ "
":ref:`packages`\\ 时进一步介绍\\ ``extends``\\ "
"条款。\ "
"现在不妨暂时把这个语句的作用当成把另一个模型的内容直接复制到当前模型内。\ "

#: ../../source/behavior/discrete/measuring.rst:29
msgid ""
"Recall the solution for the ``SecondOrderSystem`` model looks like this:"
msgstr "记得\\ ``SecondOrderSystem``\\ 模型的解如下： "

#: ../../source/behavior/discrete/measuring.rst:35
msgid ""
"In this case, we are simply plotting the solution that we computed. But in a"
" real system, we can't directly know the rotational velocity of a shaft.  "
"Instead, we have to measure it.  But measurement introduces error and each "
"measurement technique introduces different kinds of errors.  In this "
"section, we'll look at how we can model different kinds of measurement "
"techniques."
msgstr ""
"在此情况下，我们仅仅是把计算出来的解绘制出来了。\ "
"但在实际系统中，我们不可能直接知道一个轴的旋转速度。\ "
"相反，我们必须进行测量。\ "
"不过，测量误差会引入误差。\ "
"而不同的测量技术则会引入不同类型的误差。\ "
"在本节中，我们将介绍如何能够模拟各种不同的测量技术。\ "
" "

#: ../../source/behavior/discrete/measuring.rst:45
msgid "Sample and Hold"
msgstr "取样保持"

#: ../../source/behavior/discrete/measuring.rst:47
msgid ""
"The first type of measurement we will examine is a sample and hold approach "
"to measurement.  Some speed sensors have circuits for measuring the "
"rotational speed of the system.  But instead of providing a continuous value"
" for the speed, they sample it at a given point in time and then store it "
"somewhere.  This is called \"sample and hold\".  The following model "
"demonstrates how to implement a sample and hold approach to measuring the "
"angular velocity ``omega1``:"
msgstr ""
"我们将考察的第一种测量方法是用采样和保持的方法。\ "
"某些速度传感器具有测量系统旋转速度的电路。\ "
"而这些传感器并非提供连续的速度值。\ "
"传感器在给定时间点对速度进行取样，然后将其保存在某个地方。\ "
"这种方法被成为“取样保持”（sample"
" and hold）。\ "
"下面的模型展示了如何实现采用采样保持的方法测量角速度\\ ``omega1``\\ ："

#: ../../source/behavior/discrete/measuring.rst:61
msgid ""
"Note the presence of the ``discrete`` qualifier in the declaration of "
"``omega1_measured``.  This special qualifier indicates that the specified "
"variable does not have a continuous solution.  Instead, the value of this "
"variable will make (only) discrete jumps during the simulation.  It is not "
"required to include the ``discrete`` keyword but it is useful because it "
"provides additional information about the intent of the model that the "
"compiler can check (*e.g.,* making sure we never request the derivative of "
"that variable)."
msgstr ""
"请注意，变量\\ ``omega1_measured``\\ 的声明内有\\ ``discrete``\\ "
"（离散）这个限定词。\ "
"这个特殊的限定词表示指定变量不具有连续的解。\ "
"相反，这个变量的值（只）会在仿真过程中离散跃变。\ "
"加入\\ ``discrete``\\ "
"关键字并不是不需的，但此关键字有其用处。\ "
"它可以提供了模型意图的进一步信息，帮助编译器检查模型的正确性。\ "
"（例如用户不能求该变量的导数。\ "
")"

#: ../../source/behavior/discrete/measuring.rst:70
msgid "Let us now examine the solution generated by this model:"
msgstr "现在让我们来研究这个模型生成的解："

#: ../../source/behavior/discrete/measuring.rst:75
msgid ""
"The important thing to note in the solution is how the measured value is "
"piecewise-constant.  This is because the value of ``omega1_measured`` is set"
" only when the ``when`` statement becomes active.  The ``sample`` function "
"is a special built-in function that first becomes true at the time indicated"
" by the first argument (``0`` in this case) and then at regular intervals "
"after that.  The duration of these regular intervals is indicated by the "
"second argument (``sample_time`` in this case)."
msgstr ""
"值得注意的是，解中测得的值是分段恒定的。\ "
"这是因为只有仅当\\ ``when``\\ 被激活时，\\ ``omega1_measured``\\ "
"的值才会被设置。\ "
"\\ ``sample``\\ 函数是一个特殊的内建函数。\ "
"此函数在其第一个参数（在本例中值为\\ ``0``\\ "
"）所示时刻首次为真，之后在恒定间隔里所变为真。\ "
"恒定间隔的长度则有第二个参数决定（本例中为变量\\ ``sample_time``\\ ）。\ "

#: ../../source/behavior/discrete/measuring.rst:87
msgid "Interval Measurement"
msgstr "间隔测量"

#: ../../source/behavior/discrete/measuring.rst:89
msgid ""
"In the previous example, we weren't actually making any estimates for the "
"speed, we were simply reporting the value of the variable ``omega1`` only at"
" specific times.  In other words, at the moment that we sampled ``omega1`` "
"our sample was completely accurate.  But by \"holding\" our measured value "
"(instead of continuing to track ``omega1``), we introduced some artifact in "
"the measurement."
msgstr ""
"在前面的例子里，我们其实没有对速度进行估测，而是直接报告了变量\\ ``omega1``\\ 在特定时刻的值。\ "
"换句话，在我们在采样时刻得到\\ "
"``omega1``\\ 的采样值是完全准确的。\ "
"不过通过“保持”（holding）测量值（而非继续跟踪\\ ``omega1``\\ "
"变量），我们便引入了误差。\ "

#: ../../source/behavior/discrete/measuring.rst:96
msgid ""
"In the remaining examples, we will focus on techniques used to estimate the "
"speed of a rotating shaft.  In these cases, we will never make direct use of"
" the actual speed in our measurement.  Instead, we will respond to events "
"generated by the physical system and attempt to use these events to "
"reconstruct an estimate of the rotational speed."
msgstr ""
"在余下的例子中，我们重点放在用于估计旋转轴速度的技术。\ "
"在这些例子中，我们不再会在测量中直接使用实际速度。\ "
"相反，我们将立足于物理系统所产生的事件，尝试使用这些事件去重建旋转速度的估计值。\ "
" "

#: ../../source/behavior/discrete/measuring.rst:102
msgid ""
"The events that we will be responding to are generated by the discrete "
"elements attached to the spinning shaft.  For example, a typical way to "
"produce these events is to use a \"tooth wheel encoder\".  A tooth wheel "
"encoder includes a gear on the rotating shaft.  On either side of the gear, "
"we place a light source and a light sensor.  As the gear teeth pass in front"
" of the light source, they block the light.  The result is that the signal "
"from the light sensor will include an approximate square wave.  The leading "
"edge of these square waves are the events we will be responding to."
msgstr ""
"这些我们要处理的事件产生自连接在旋转轴的离散元件。\ "
"例如，一种典型生产这些事件的方法是使用“齿轮编码器”。\ "
"齿轮编码器包括一个在旋转轴上的齿轮。\ "
"在齿轮的两侧，我们将放置光源和光传感器。\ "
"随着齿轮的齿通过在光源的前面，齿轮会挡住光线。\ "
"其结果是，光传感器的信号将给出一个近似方波信号。\ "
"这些方波的前缘便是我们需要响应的事件。\ "

#: ../../source/behavior/discrete/measuring.rst:112
msgid ""
"The first estimation method we will examine computes the speed of the shaft "
"by measuring the time interval that passes between events. Knowing that "
"these events occur whenever the shaft has rotated by an angle of "
":math:`\\Delta\\theta`, we can estimate the speed as:"
msgstr ""
"我们研究的第一种测算方法是通过测量事件之间经过的时间间隔来计算轴的转速。\ "
"既然我们知道，每当轴旋转\\ :math:`\\Delta\\theta`\\ "
"角度时这些事件便会发生，我们可以如此测算转速："

#: ../../source/behavior/discrete/measuring.rst:121
msgid "This technique for speed estimation can be represented in Modelica as:"
msgstr "这种速度测算方法可用Modelica表示为："

#: ../../source/behavior/discrete/measuring.rst:135
msgid "Let's take a close look at the ``when`` statement in this model:"
msgstr "让我们来仔细看一下这个模型中的\\ ``when``\\ 语句："

#: ../../source/behavior/discrete/measuring.rst:141
msgid ""
"Here, we use the vector expression syntax used previously in the :ref"
":`bouncing-ball` example.  Recall that the ``when`` statement becomes active"
" if **any** of the conditions become true.  In this case, the ``when`` "
"statement becomes active if the angle, ``phi1``, becomes greater than "
"``next_phi`` or less than ``prev_phi``."
msgstr ""
"在这里，我们使用了之前在\\ :ref:`bouncing-ball`\\ 例子中用过的矢量表达式语法。\ "
"请记住，如果其中的\\ **任何**\\ "
"条件的变为真，那么\\ ``when``\\ 语句便会被激活。\ "
"在这里，一旦角度\\ ``phi1``\\ 大于\\ ``next_phi``\\ "
"或小于\\ ``prev_phi``\\ ，那么\\ ``when``\\ 语句便会被激活。\ "

#: ../../source/behavior/discrete/measuring.rst:147
msgid ""
"Another thing to note is the use of the ``pre`` operator throughout the "
"``when`` statement.  When an event occurs in a model, there is a chance that"
" the value of some variables may change discontinuously. During an event, "
"while we are trying to resolve what values all the variables should have as "
"a result of the event, the ``pre`` operator allows us to reference the value"
" of a variable **prior** to the event. The ``pre`` operator is used in this "
"model to refer to the previous (pre-event) values of ``next_phi``, "
"``prev_phi`` and ``last_time``. The ``pre`` operator is necessary because "
"all of these variables are affected by the statements inside the ``when`` "
"statement.  So, for example, ``last_time`` (without the ``pre`` operator) "
"refers to the value of ``last_time`` at the conclusion of the event while "
"``pre(last_time)`` refers to the value of ``last_time`` prior to any event "
"occurring."
msgstr ""
"另外需要注意是在整个\\ ``when``\\ 语句里使用的\\ ``pre``\\ "
"操作符。\ "
"模型内发生事件时，变量值可能会非连续地改变。\ "
"在一个事件中，当我们试图计算所有变量受事件影响后的取值时，\\ ``pre``\\ "
"操作符允许我们引用变量在事件\\ **之前**\\ 的值。\ "
"这里的\\ ``pre``\\ 操作符在该模型中的作用是引用\\ ``next_phi``\\"
" 、\\ ``prev_phi``\\ 以及\\ ``last_time``\\ 在之前（事件前）的值。\ "
"由于所有变量都受到在\\ ``when``\\ "
"内部语句的影响，因此\\ ``pre``\\ 操作符是必须的。\ "
"所以，例如\\ ``last_time``\\ （没有\\ ``pre``\\ "
"操作符）指代的是\\ ``last_time``\\ 在事件结束时的取值。\ "
"而\\ ``pre(last_time)``\\ 指代的则是\\ "
"``last_time``\\ 在任何事件发生前的取值。\ "

#: ../../source/behavior/discrete/measuring.rst:0
msgid "Use of the ``pre`` operator"
msgstr "\\ ``pre``\\ 操作符的使用"

#: ../../source/behavior/discrete/measuring.rst:164
msgid ""
"In general, if a variable changes as a result of a ``when`` statement "
"becoming active, you **almost always** want to use the ``pre`` operator when"
" referring to that variable in the conditional expression associated with "
"the ``when`` statement (as we have done in the previous example).  This "
"makes it clear that you are responding to what was happening before the "
"``when`` statement was triggered."
msgstr ""
"一般而言，如果一个变量的变化是由被激活的\\ ``when``\\ 语句造成的，那么在\\ ``when``\\ "
"语句使用的条件表达式与上述会被更改的变量相关联时，你\\ **几乎总是**\\ 需要使用\\ ``pre``\\ "
"操作符来指代这个变量（正如我们在前例中做的一样）。\ "
"这清楚地表明，你是回应\\ ``when``\\ 语句触发之前系统的状态。\ "

#: ../../source/behavior/discrete/measuring.rst:172
msgid "Let's take a look at the speed estimates provided by this approach:"
msgstr "让我们看看用上述方法给出的速度测算值："

#: ../../source/behavior/discrete/measuring.rst:177
msgid ""
"There are two important properties of this estimation algorithm that we can "
"immediately see in these results.  The first is that the estimate is "
"unsigned.  In other words, we cannot tell from a device like a tooth wheel "
"encoder which **direction** the shaft is rotating. Also, low speeds and "
"changes in rotational direction can degrade the accuracy of the estimate "
"significantly.  The results are also very sensitive the number of teeth "
"involved.  If we were to reduce the number of teeth used in our encoder by "
"setting ``teeth`` to 20, we'd get very different results."
msgstr ""
"从以上结果我们可以马上看到这个测算算法的两个重要特性。\ "
"首先，测算结果是无符号的。\ "
"也就是说，我们无法使用类似齿轮编码器的装置得知轴转动的\\ "
"**方向**\\ 。\ "
"其次，低转速和旋转方向的改变可以显著降低测算的准确性。\ "
"结果对齿轮的齿数也非常敏感。\ "
"如果我们把编码器中齿的数量即参数\\ "
"``teeth``\\ 减少为20，我们将得到十分不同的结果。\ "

#: ../../source/behavior/discrete/measuring.rst:190
msgid ""
"To understand exactly why the measured signal is so inaccurate, it helps to "
"consider the following plot which shows how the angle, ``phi1`` compares to "
"the angles associated with the adjacent teeth, ``next_phi`` and "
"``prev_phi``."
msgstr ""
"为何测量信号如此地不准确呢？为了明白这一点，大家可以观察下列图表，对比变量\\ ``phi1``\\ 和下列相邻齿的角位置\\ "
"``next_phi``\\ 以及\\ ``prev_phi``\\ 。\ "

#: ../../source/behavior/discrete/measuring.rst:198
msgid ""
"In this plot, we can clearly see how relatively low speeds and speed "
"reversals create irregular events that introduce significant estimation "
"error."
msgstr "在这个图里，我们可以清楚地看到，较低的转速以及反转都会产生不规则的事件。\ "
"这会从而引入显著估计误差。\ "

#: ../../source/behavior/discrete/measuring.rst:205
msgid "Pulse Counting"
msgstr "脉冲计数"

#: ../../source/behavior/discrete/measuring.rst:207
msgid ""
"The interval measuring technique mentioned above requires hardware that can "
"perform speed calculations on hardware interrupts.  Another approach to "
"estimating speed is the count how many events occur within a given (fixed) "
"time interval and use that as an estimate of speed. Using this method, only "
"the summation of events occurs when the events occur and the calculations "
"are deferred to a regularly scheduled update."
msgstr ""
"上述时间间隔测量技术需要能在硬件中断时执行速度计算的硬件。\ "
"另一种估测速度的方法需要对（固定）时间间隔内发生的事件数目进行计数，并以此作为速度的估算值。\ "
"使用这种方法，在事件发生时仅仅会进行事件总数的求和运算，实际的计算则只会在定期更新时进行。\ "

#: ../../source/behavior/discrete/measuring.rst:215
msgid ""
"Building on the previous examples in this section, the following seems like "
"a natural way to create a model that implements this estimation technique:"
msgstr "基于本节前面的例子，我们似乎会很自然地用以下形式在模型里实现这种估测技术："

#: ../../source/behavior/discrete/measuring.rst:224
msgid ""
"However, there is a problem in this model.  Note that there are actually "
"**two** equations for ``count``.  Trying to compile such a model will lead "
"to a situation where there are more equations than variables (*i.e.,* the "
"problem is singular)."
msgstr ""
"然而，此模型有一个问题。\ "
"注意\\ ``count``\\ 变量实际上有\\ **两个**\\ "
"方程。\ "
"如果我们尝试编译这样的模型就会导致方程数量超过变量数量。\ "
"（\\ *也就是说*\\ 问题是奇异的。\ "
"）"

#: ../../source/behavior/discrete/measuring.rst:229
msgid ""
"So what can we do about this?  We need two different equations because the "
"updates to ``count`` occur in response to different events.  We could try to"
" formulate everything under a single ``when`` statement, like this:"
msgstr ""
"那么，我们应该如何处理这种情况呢？之所以需要两个不同的方程，是因为在更新\\ ``count``\\ "
"时，我们需要对不同的事件作出不同的反应。\ "
"我们可以尝试用如下形式将需求表达为一个\\ ``when``\\ 语句，："

#: ../../source/behavior/discrete/measuring.rst:248
msgid ""
"But this kind of code quickly becomes hard to read.  Fortunately, we can "
"address this situation by placing all the ``when`` statements in an "
"``algorithm`` section."
msgstr ""
"但是，这种代码很快就会变得难以阅读。\ "
"幸运的是，我们可以通过把所有的\\ ``when``\\ 陈述中放在\\ ``algorithm``\\ "
"（算法）区域以解决这个问题。\ "

#: ../../source/behavior/discrete/measuring.rst:252
msgid ""
"The nature of an ``algorithm`` section is that it is treated as one single "
"equation for any variables that are assigned within it.  This allows "
"multiple assignments to ``count``, for example.  When using an ``algorithm``"
" section, it is very important to understand that the **order** of "
"assignment becomes important.  If a conflict should arise (*e.g.,* a "
"variable is assigned two values within the same ``algorithm`` section), the "
"last one is the one that will be used.  Another thing to note about "
"``algorithm`` sections is that you cannot write general equations.  Instead,"
" you must write *assignment statements*."
msgstr ""
"\\ ``algorithm``\\ 区域的特性是对于任何在其内部进行赋值的变量而言，它都仅被视为是一个等式。\ "
"譬如说，这个特性让\\ "
"``count``\\ 变量可以被多次赋值。\ "
"使用\\ ``algorithm``\\ 区域时，读者必须明白赋值的\\ **顺序**\\ "
"不再无足轻重。\ "
"如果有冲突出现时（例如在同一个\\ ``algorithm``\\ 区域内一个变量被赋了两个值），那么只有最后一个会被使用。\ "
"对于\\ "
"``algorithm``\\ 区域我们还需要注意另外一点，就是它并不支持一般意义的等式。\ "
"相对地，大家必须使用\\ *赋值语句*\\ 。\ "

#: ../../source/behavior/discrete/measuring.rst:276
msgid ""
"In our case, there are no significant consequences to using the "
"``algorithm`` section.  Here is an example of how the previous estimation "
"algorithm could be refactored using an ``algorithm`` section:"
msgstr ""
"在本例里\\ ``algorithm``\\ 区域的使用并不会带来显著的影响。\ "
"以下是将前述测算方法用\\ ``algorithm``\\ "
"区域重构后的结果："

#: ../../source/behavior/discrete/measuring.rst:285
msgid ""
"The simulated results of this estimation technique can be seen in the "
"following plot:"
msgstr "测算方法的仿真结果见下图："

#: ../../source/behavior/discrete/measuring.rst:291
msgid ""
"Again, we see that this approach cannot determine the direction of rotation."
"  With the following plot, we can get a sense of how many events occur "
"within each sample interval:"
msgstr "同样，我们可以看到这种方法并不能确定旋转的方向。\ "
" 由下图，我们可以对每个采样间隔内发生事件的数量有一个大概的感觉："

#: ../../source/behavior/discrete/measuring.rst:298
msgid ""
"In general, the higher the count gets in an interval, the more accurate the "
"estimate."
msgstr "在一般情况下，间隔内计数越高，测算结果就越准确。\ "

#: ../../source/behavior/discrete/measuring.rst:302
msgid "Conclusion"
msgstr "结论"

#: ../../source/behavior/discrete/measuring.rst:304
msgid ""
"This section demonstrates how we can use the ``when`` construct to respond "
"to physical events that occur in our system.  These kinds of events and the "
"impact they have on our system are just as important as the continuous "
"dynamics we've covered previously.  The ability to capture and respond to "
"these physical events is an important part of why Modelica is so well suited"
" to model complete systems since those system frequently include both "
"continuous and discrete behavior."
msgstr ""
"本节说明如何可以通过\\ ``when``\\ "
"这一语言特性对发生在系统中的物理事件作出响应。\ "
"这类事件及其对系统的影响，对比我们之前讨论过的连续时间动力学特性，其实同样重要。\ "
"由于完整系统通常包括连续的和不连续行为，Modelica对上述事件的发现和应对能力是其适合用于系统建模的重要原因。\ "
"。\ "

#: ../../source/behavior/discrete/measuring.rst:262
msgid ""
"In this way, an ``algorithm`` section is very much like the way most "
"programming languages work.  The statements in the algorithm section are "
"executed in order and each statement isn't interpreted as an equation, but "
"rather as an assignment of an expression to a variable. The familiarity of "
"assignment statements may make using ``algorithm`` sections attractive to "
"people with a programming background who find the otherwise equation "
"oriented aspects of Modelica disorienting and unfamiliar.  But be aware that"
" one big reason to avoid ``algorithm`` sections is because they interfere "
"with the symbolic manipulation performed by the Modelica compiler.  This can"
" result in both poor simulation performance and a loss of flexibility in how"
" you compose your models.  So it is best to use an ``equation`` section "
"whenever possible."
msgstr ""
"在这个方面上，\\ ``algorithm``\\ "
"区域的工作方式与大多数编程语言非常相像。\ "
"在算法区域的语句是顺序执行的，且每个语句不被解析为等式而是作为给变量赋值的表达式。\ "
"具有某些编程背景的人们可能会觉得Modelica面向公式的一面既迷惑又陌生。\ "
"对于他们而言，熟悉的赋值语句可能是很诱人的。\ "
"但需要注意，之所以要避免\\"
" ``algorithm``\\ "
"区域的一大原因是，它会干扰Modelica语言编译器进行的符号运算。\ "
"这既会导致仿真性能不佳，又会让你在建模时丧失灵活性。\ "
"因此，大家最好尽可能地使用\\ "
"``equation``\\ 区域。\ "

#: ../../source/behavior/discrete/measuring.rst:127
msgid ""
"where ``tooth_angle`` represents :math:`\\Delta\\theta`.  Note how "
"``tooth_angle`` is not something the user needs to specify.  Instead, the "
"user specifies the number of teeth using the ``teeth`` parameter. The "
"``tooth_angle`` parameter is then computed using the value of ``teeth`` "
"(note that while we have hand coded the value of :math:`pi` here, we'll "
"learn how to avoid this later in the book when we talk about "
":ref:`constants`)."
msgstr ""
"其中\\ ``tooth_angle``\\ （齿角）表示\\ :math:`\\Delta\\theta`\\ 。\ "
"注意\\ "
"``tooth_angle``\\ 并不需要用户指定。\ "
"用户使用\\ ``teeth``\\ 参数指定齿轮的齿数。\ "
"\\ ``tooth_angle``\\"
" 参数的值会由参数\\ ``teeth``\\ 计算（注意，虽然我们在这里手工输入了\\ :math:`\\pi`\\ 的值，我们将在本书的\\ "
":ref:`constants`\\ 中学习如何在以后避免这种情况）。\ "
