#
msgid ""
msgstr ""
"Project-Id-Version: Modelica by Example 0.2.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-04-14 10:14-0400\n"
"PO-Revision-Date: 2014-09-23 12:20+0100\n"
"Last-Translator: Dongping Xie <dongping.xie.tud@gmail.com>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/behavior/discrete/cooling.rst:4
msgid "Cooling Revisited"
msgstr "再探冷却"

#: ../../source/behavior/discrete/cooling.rst:7
msgid "Changing Ambient Conditions"
msgstr "改变环境条件"

#: ../../source/behavior/discrete/cooling.rst:9
msgid ""
"We will start with a simple example that demonstrates time events.  We will "
"revisit the thermal model introduced previously in the section on :ref"
":`physical-types`.  However, this time we will introduce a disturbance to "
"that system.  Specifically, we will trigger an abrupt decrease in the "
"ambient temperature after half a second of simulation. This revised model is"
" written as follows:"
msgstr ""
"我们将从一个简单的例子开始介绍了时间事件。\ "
"我们将重新审视在前面\\ :ref:`physical-types`\\ "
"中介绍的热学模型。\ "
"不过，这次我们将对该系统添加一个扰动。\ "
"具体地说，我们将仿真开始的半秒后让环境温度的突然下降。\ "
"修正后的模型可以如下："

#: ../../source/behavior/discrete/cooling.rst:23
msgid ""
"The highlight lines show an ``if`` statement.  This particular ``if`` "
"statement provides two different equations for computing ``T_inf``."
msgstr "高亮行为\\ ``if``\\ 语句。\ "
"这条特定的\\ ``if``\\ 语句为\\ ``T_inf``\\ 的计算提供两条不同的等式。\ "

#: ../../source/behavior/discrete/cooling.rst:0
msgid "Time"
msgstr "时间变量"

#: ../../source/behavior/discrete/cooling.rst:28
msgid ""
"You will note in this model the variable ``time`` is not declared within our"
" model.  This is because ``time`` is a built-in variable in all Modelica "
"models."
msgstr "你会注意到这个模型中没有声明变量\\ ``time``\\ 。\ "
"之所以如此是因为\\ ``time``\\ 是一个内置在所有Modelica模型内的变量。\ "

#: ../../source/behavior/discrete/cooling.rst:32
msgid ""
"The decision about which of the two equations will actually be used depends "
"on the conditional expression ``time<=0.5``.  It is because this expression "
"only depends on ``time`` and not any other variables in our model that we "
"can characterize the transition between these two equations as a \"time "
"event\".  The key point is that when integrating these equations, we can "
"tell the solver that integrates our system of equations to stop precisely at"
" 0.5 seconds and then resume again using a different equation.  We'll see "
"examples of other state events where this would not be possible, in the next"
" section when we present the classic :ref:`bouncing-ball` example."
msgstr ""
"两个方程中实际使用哪个依赖于条件表达式\\ ``time<=0.5``\\ 。\ "
"正因为这个表达式仅仅取决于\\ ``time``\\ "
"，而不是在模型中的任何其他变量，我们可以把这两个公式之间的转换称为“时间事件”。\ "
"关键的一点是，对这些方程进行积分时，我们可以告诉对方程组进行积分的求解器精确地停在第0.5秒，然后继续使用不同的公式进行求解。\ "
"在下一节我们介绍的经典的\\"
" :ref:`bouncing-ball`\\ 例子里，我们会看到对于其他状态的事件而言，这是不可能的。\ "

#: ../../source/behavior/discrete/cooling.rst:43
msgid ""
"But for now, let us continue with our cooling example.  If we simulate this "
"model for one second, we get the following temperature trajectory:"
msgstr "但是现在，让我们继续考虑我们的冷却例子。\ "
"如果我们对这个模型进行一秒钟的仿真，我们将得到以下的温度轨迹："

#: ../../source/behavior/discrete/cooling.rst:58
msgid "Initial Transients"
msgstr "初始瞬态"

#: ../../source/behavior/discrete/cooling.rst:72
msgid ""
"As we learned during our discussion of :ref:`initialization`, we can solve "
"this problem of initial transients by simply including an initial equation "
"that will determine a value for ``T`` such that our system starts in an "
"equilibrium state, *i.e.,*"
msgstr ""
"正如我们在\\ :ref:`initialization`\\ "
"中的讨论所了解到的一样，我们可以通过添加初始方程解决初始瞬态的问题。\ "
"我们用初始方程找到这样的一个\\ ``T``\\ "
"值，使得我们的系统从平衡态开始仿真，即："

#: ../../source/behavior/discrete/cooling.rst:82
msgid ""
"The only thing we've changed is the initial equation.  Instead of starting "
"our system at some fixed temperature, we start it at a temperature such that"
" the change in temperature (at least initially, prior to our disturbance) is"
" zero.  Now the temperature response no longer includes any initial "
"transient and we can focus only on the response to the disturbance:"
msgstr ""
"我们唯一改变了的是初始化的方程。\ "
"相比从某一固定温度开始系统的仿真，我们现在让仿真开始时温度的变化为零（至少在一开始没有外加扰动影响的时候）。\ "
"现在的温度响应不再包括任何初始瞬态，我们可以只专注于系统对干扰的响应。\ "

#: ../../source/behavior/discrete/cooling.rst:95
msgid "Compactness"
msgstr "简洁性"

#: ../../source/behavior/discrete/cooling.rst:97
msgid ""
"One issue with ``if`` statements is that they can make relatively simple "
"changes in behavior appear quite complicated.  There are a couple of "
"alternative constructs we can use to get the same behavior with fewer lines "
"of code."
msgstr "\\ ``if``\\ 语句的一个问题是，它们可以让相对简单的行为变化看起来相当复杂。\ "
"我们可以用好几种另外的语法结构以更少的代码获得相同的行为。\ "

#: ../../source/behavior/discrete/cooling.rst:104
msgid ""
"The first approach is to use an ``if`` **expression**.  Whereas an ``if`` "
"statement includes \"branches\" containing equations, an ``if`` expression "
"has branches that contain only expressions.  Furthermore, the syntax for an "
"``if`` expression is also less verbose.  If we had chosen to use an ``if`` "
"expression our ``equation`` could have been simplified to:"
msgstr ""
"第一种方法是使用一个\\ ``if``\\ **表达式**\\ 。\ "
"相对于包含方程组“分支”的\\ ``if``\\ 语句，\\ ``if``\\ "
"表达式只包含表达式分支。\ "
"此外，语法上\\ ``if``\\ 表达式也更为简洁。\ "
"倘若我们使用\\ ``if``\\ 表达式，我们的\\ "
"``equation``\\ 部分会被简化为："

#: ../../source/behavior/discrete/cooling.rst:117
msgid ""
"Alternatively, we could use one of the many built-in Modelica functions, "
"like ``max``, to represent the change in the ambient temperature, *e.g.,*"
msgstr "此外，我们可以使用许多Modelica的内置函数，如\\ ``max``\\ 来表示在环境温度的变化，例如："

#: ../../source/behavior/discrete/cooling.rst:126
msgid "Events"
msgstr "事件"

#: ../../source/behavior/discrete/cooling.rst:128
msgid ""
"We've seen several ways to express the fact that there is an abrupt change "
"in the behavior of our system.  But it's important to point out that we are "
"not just describing a change in the ambient temperature, we are also "
"specifying **when** it changes.  This a subtle, but very important, point."
msgstr ""
"我们已经看到了几种方式来表达在系统行为的突然变化。\ "
"但要特别指出的是，我们不仅仅描述了环境温度的变化，我们也规定了\\ **何时（when）**\\ "
"它会发生变化。\ "

#: ../../source/behavior/discrete/cooling.rst:134
msgid ""
"Consider the last example, where our system began in an equilibrium state.  "
"At the start of the simulation, there are no significant dynamics.  Since "
"nothing is really changing in the system, the integrator is unlikely to "
"accumulate significant integration error. So, in order to minimize the "
"amount of time required to complete the simulation, variable time step "
"integrators will, in such circumstances, increase their step size."
msgstr ""
"考虑最后一个例子：我们的系统初始状态是一个平衡态。\ "
"在仿真的开始，系统没有显著的动态。\ "
"因为系统中并没有真正变化，积分器是不可能积累显著的积分误差。\ "
"所以，为了最小化完成仿真所需的时间，可变步长的积分器会在这样的情况下提高其步长。\ "

#: ../../source/behavior/discrete/cooling.rst:142
msgid ""
"There is, however, a risk in doing this.  The risk is that the integrator "
"may get \"blind-sided\" by a sudden disturbance in the system.  If such a "
"disturbance were to occur, the integrator's assumptions that a large step "
"will not lead to significant integration error would not be true."
msgstr ""
"但这样做有其风险。\ "
"风险在于，系统中突然的扰动可能会让积分器“措手不及” "
"。\ "
"如果发生了这样的扰动，积分器对于大步长不会导致显著积分误差的假设，便不再成立了。\ "

#: ../../source/behavior/discrete/cooling.rst:148
msgid ""
"The question then becomes, how can the integrator *know* when it can take a "
"large time step and when it cannot.  Typically, these integration schemes "
"use a kind of trial and error approach.  They try to take large step and "
"then estimate the amount of error introduced by that step.  If it is less "
"than some threshold, then they accept the state (or perhaps try a larger "
"step).  If, on the other hand, the step introduces too much error, then they"
" try a smaller step.  But they cannot know how small a step will be required"
" to get under the error threshold, which means they will continue to blindly"
" try smaller and smaller steps."
msgstr ""
"那么问题就变成，积分器如何\\ *知道*\\ "
"何时它可以使用一个大的时间步长，何时不能。\ "
"通常情况下，这些积分方案使用一种试错法。\ "
"积分器试图使用大步长，然后估算由该步长引入的误差。\ "
"如果误差小于某个阈值，则积分器接受新算出的状态（或可能尝试更大的步长）。\ "
"但倘若在该步长引入了过多的错误，那么积分器便尝试较小的步长。\ "
"但它们不知道为了符合误差阈值要求需要多小的步长。\ "
"这意味着它们将盲目地尝试更小的步长，直到符合条件。\ "

#: ../../source/behavior/discrete/cooling.rst:159
msgid ""
"But Modelica is about much more than integrating the underlying system.  "
"Modelica compilers study the **structure** of the problem. In all of our "
"examples, the compiler can see that there is a distinct change in behavior."
"  Not only that, it can see that this change in behavior is a time event, "
"*i.e.,* an event whose time is known *a priori* without any knowledge of the"
" solution trajectory."
msgstr ""
"但Modelica不止是关于相关系统的积分。\ "
"Modelica编译器研究问题的\\ **结构**\\ "
"。\ "
"在我们的所有例子中，编译器都可以看到系统有一个明显的行为变化。\ "
"不仅如此，它可以看到这个行为改变是一个时间事件。\ "
"亦即一个这样的一个事件，其发生时间被先验地、不需要任何关于解的轨迹的信息就被确定"

#: ../../source/behavior/discrete/cooling.rst:166
msgid ""
"So, what a Modelica compiler will do is inform the underlying integrator "
"that there will be an abrupt change in behavior at 0.5 seconds and it will "
"instruct the integrator to simply integrate exactly up to that point and no "
"further.  As a result, the abrupt change never occurs **within a time "
"step**.  Instead, the integrator will simply restart on the other side of "
"the event.  This completely avoids the blind searching for the cutoff time "
"that minimizes the error in the step.  Instead, the integrator will "
"integrate right up to that point automatically and then restart after that "
"point."
msgstr ""
"因此，Modelica语言编译器会告诉底层的积分器，在第0.5秒时系统行为会突然发生变化，然后它会指导积分器一步不多地积到该时点。\ "
"结果，\\ "
"**在时间步长内**\\ "
"从不会发生急剧的变化。\ "
"相反，该积分器会简单地在该事件的另一侧重新开始积分。\ "
"这完全避免为了最小化步长内的误差而去盲目搜索截止时间。\ "
"相反，该积分器会自动恰好积到该点，然后在该点后重新启动。\ "

#: ../../source/behavior/discrete/cooling.rst:176
msgid ""
"This is one of many examples of features in Modelica that optimize the way a"
" simulation is carried out.  A more detailed discussion of this kind of "
"handling can be found in the upcoming section on :ref:`events`.  In the "
"coming sections, we'll also see more complex examples of events that depend "
"on the solution variables."
msgstr ""
"Modelica语言有众多能优化仿真进行方式的特性。\ "
"这是一个其中一个例子。\ "
"读者可以在关于\\ :ref:`events`\\ "
"的紧接小节中找到对于事件处理的进一步讨论。\ "
"在接下来的章节中，我们还可以看到另一种更复杂事件的例子。\ "
"这种事件会依赖于解中的变量的值。\ "

#: ../../source/behavior/discrete/cooling.rst:50
msgid ""
"As you can see in these results, the ambient temperature does indeed start "
"to decrease after half a second.  In studying the dynamic response of the "
"temperature itself, we see two distinct phases.  The first phase is the "
"initial transient response toward equilibrium (to match the ambient "
"temperature).  The second phase is the tracking of the ambient temperature "
"as it decreases."
msgstr ""
"正如你在这些结果中看到的，环境温度确实在半秒后开始减少。\ "
"在研究的温度本身的动态响应时，我们看到两个不同的阶段。\ "
"第一阶段是趋向平衡态的初始瞬态响应（从而和环境温度相匹配）。\ "
"第二阶段是随在环境温度的减小的进行的追踪。\ "

#: ../../source/behavior/discrete/cooling.rst:60
msgid ""
"It is worth noting that this is a very common issue in modeling. Frequently,"
" you wish to model the systems response to some disturbance (like the "
"ambient temperature decrease in this case).  However, if you don't start "
"your system in some kind of equilibrium state, the system response will also"
" include some kind of initial transient (like the one shown here).  In order"
" to distinguish these two responses clearly, we want to avoid any overlap "
"between them.  **The simplest way to do that is to start the simulation in "
"an equilibrium condition** (as discussed previous in our discussion of :ref"
":`steady-state`).  This avoids the initial transient altogether and allows "
"us to focus entirely on the disturbance that we are interested in."
msgstr ""
"值得注意的是，这是建模中一个的非常常见的问题。\ "
"你常常要模拟的是系统对一些扰动的响应（如在此例中环境温度的下降）。\ "
"但是，如果系统开始时不处于某种平衡态下，系统响应将包括某种形式的初始瞬态（图示）。\ "
"为了清楚地区分这两种响应，我们要避免它们之间有任何重叠。\ "
"\\ **要做到这一点最简单的方法就是从平衡态开始仿真**\\ "
"（参见我们之前在\\ :ref:`steady-state`\\ 的讨论）。\ "
"这完全避免了初始瞬态，允许我们完全专注于我们所感兴趣的扰动。\ "
