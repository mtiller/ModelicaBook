# 
msgid ""
msgstr ""
"Project-Id-Version: Modelica by Example 0.2.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-04-14 10:14-0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/behavior/discrete/sampling.rst:4
msgid "Synchronous Systems"
msgstr "同步系统"

#: ../../source/behavior/discrete/sampling.rst:6
msgid ""
"In Modelica version 3.3, new features were introduced to address concerns "
"about non-deterministic discrete behavior [Elmqvist]_.  In this section, "
"we'll present some examples of how these issues presented themselves before "
"version 3.3 and show how these new features help address them."
msgstr ""
"Modelica语言3.3版引入了一个新功能以解决有关非确定性离散行为的问题\\ [Elmqvist]_ \\ "
"。\ "
"本节将先介绍这些问题在3.3版本之前的表现。\ "
"然后，我们将用例子展示这些新特性能如何帮助解决这类问题。\ "

#: ../../source/behavior/discrete/sampling.rst:12
msgid "To start, consider the following model:"
msgstr "先考虑下列模型："

#: ../../source/behavior/discrete/sampling.rst:18
msgid ""
"If you look carefully, you will see that ``x`` and ``y`` are both computed "
"at discrete times.  Furthermore, they are both sampled initially at the "
"start of the simulation and then again every 0.1 seconds.  But the question "
"is, are they really identical?  To help address this question, we include "
"the variable ``e`` which measures the difference between them."
msgstr ""
"倘若你仔细观察，你会发现\\ ``x``\\ 和\\ ``y``\\ "
"都在离散的时间点上被计算。\ "
"此外，两变量的采样时点都是在仿真开始时以及之后的每0.1秒。\ "
"但问题是，它们真的一样吗？为了更容易解决这个问题，我们加入变量\\"
" ``e``\\ 以计算两者间的差。\ "

#: ../../source/behavior/discrete/sampling.rst:28
msgid ""
"Simulating this model, we get the following trajectories for ``x`` and "
"``y``.  Of course, they look identical.  But in order to really determine if"
" there are any differences between them, let's plot the error value, ``e``:"
msgstr ""
"对模型进行仿真，我们会得到如下的\\ ``x``\\ 、\\ ``y``\\ 轨迹。\ "
"当然，两个轨迹看上去是一样的。\ "
"但要真正确定它们之间是否存在任何不同，我们绘制了误差值\\ ``e``\\ ："

#: ../../source/behavior/discrete/sampling.rst:36
msgid "Now, let's consider the following model:"
msgstr "现在，让我们考虑一下模型："

#: ../../source/behavior/discrete/sampling.rst:42
msgid ""
"Here, we set up a common signal that triggers the assignment to both "
"variables.  In this way, we can be sure that when the ``tick`` signal "
"becomes true, both ``x`` and ``y`` will be assigned a value.  Sure enough, "
"if we run this model, we see that the error is always zero:"
msgstr ""
"在这里，我们设置了一个共同的信号以触发两个变量的赋值操作。\ "
"通过这种方式，我们可以确定，当\\ ``tick``\\ 信号变为真时，无论是\\ "
"``x``\\ 还是\\ ``y``\\ 都将被赋予一个值。\ "
"显然，运行这个模型后我们可以看到，误差永远为零："

#: ../../source/behavior/discrete/sampling.rst:50
msgid ""
"This kind of approach, where each signal is sampled based on a common "
"\"tick\" (or clock), is a good way to avoid determinism issues.  However, "
"what about cases where you have one signal that samples at a higher rate "
"than another, but you know that at certain times they should be sampled "
"together?  Consider the following example:"
msgstr ""
"在这样的做法里，每个信号都是基于一个共同的“节拍”（或时钟）"
"进行取样的。\ "
"这是一个很好的避免确定性问题的方式。\ "
"但是，如果你有两个不同频率的信号，且已知在特定的时点两者会被同时取样，那么情况又是如何呢？请考虑如下例子："

#: ../../source/behavior/discrete/sampling.rst:60
msgid ""
"In this case, the variable ``tick`` is a counter.  Every time it changes, we"
" update the values of ``x`` and ``y``.  So this much is identical to the "
"previous models.  However, we added a third signal, ``z``, that is sampled "
"only when the value of ``tick`` is odd.  So ``x`` and ``y`` are sampled "
"twice as often.  But every time ``z`` is updated, we can be sure that ``x`` "
"and ``y`` are updated at exactly the same time.  Simulating this model gives"
" us:"
msgstr ""
"在这种情况下，变量\\ ``tick``\\ 是计数器。\ "
"每次此变量改变时，我们会更新\\ ``x``\\ 和\\ ``y``\\ "
"的值。\ "
"所以，直到这一点都是与先前的模型相同的。\ "
"然而，我们增加了第三个信号\\ ``z``\\ 。\ "
"而该信号仅在当\\ ``tick``\\ "
"值是为奇时才会进行采样。\ "
"所以相比之下，\\ ``x``\\ 和\\ ``y``\\ 的采样次数为其的两倍。\ "
"但我们可以肯定的是，每次\\ ``z``\\ "
"更新时，\\ ``x``\\ 和\\ ``y``\\ 是在完全相同的时点进行更新。\ "
"对模型进行仿真我们会得到一下结果："

#: ../../source/behavior/discrete/sampling.rst:71
msgid ""
"This is the approach taken in Modelica prior to version 3.3.  But version "
"3.3 introduced some new features that allow us to more easily express these "
"situations."
msgstr "这是Modelica语言在3.3版本之前所采用的方法。\ "
"但3.3版本引入了一些新的功能以帮助我们表述这些情况。\ "

#: ../../source/behavior/discrete/sampling.rst:75
msgid "Consider the following model:"
msgstr "请考虑以下模型："

#: ../../source/behavior/discrete/sampling.rst:81
msgid ""
"Now, instead of relying on a ``when`` statement, we use an enhanced version "
"of the ``sample`` function where the first argument is an expression to "
"evaluate to determine the sampled value and the second argument is used to "
"tell us when to evaluate it.  Let's work through these lines one by one and "
"discuss them.  First we have:"
msgstr ""
"现在我们不再使用\\ ``when``\\ 语句。\ "
"相反，我们会使用一个增强版的\\ ``sample``\\ （取样）函数。\ "
"这个\\ ``sample``\\ "
"函数的首个参数是待取样的表达式，第二个参数则是取样的时间间隔。\ "
"让我们逐行阅读并讨论下面的代码。\ "
"首先，我们有："

#: ../../source/behavior/discrete/sampling.rst:153
msgid ""
"\"Fundamentals of Synchronous Control in Modelica\", Hilding Elmqvist, "
"Martin Otter and Sven-Erik Mattsson "
"http://www.ep.liu.se/ecp/076/001/ecp12076001.pdf"
msgstr ""

#: ../../source/behavior/discrete/sampling.rst:91
msgid ""
"Note that we have done away with the ``0.1``.  We no longer see any mention "
"of the clock interval as a real number.  Instead, we use the ``Clock`` "
"operator to the define clock interval for ``x`` as a rational number.  This "
"is important because it allows us to do exact comparisons between clocks.  "
"This brings us to the next line:"
msgstr ""
"注意，我们已经不再使用\\ ``0.1``\\ ，而且不再能看到表示为实数值的时钟间隔。\ "
"相反，我们使用\\ ``Clock``\\ 表达式为\\ "
"``x``\\ 定义一个有理数值的时钟间隔。\ "
"这一点很重要，因为这种做法允许我们对不同时钟进行精确比较。\ "
"让我们看下一行："

#: ../../source/behavior/discrete/sampling.rst:101
msgid ""
"Again, we see the rational representation of the clock.  What this means, in"
" practice, is that the Modelica compiler can know for certain that these two"
" clocks, ``x`` and ``y``, are identical because they are defined in terms of"
" integer quantities which allow exact comparison. This means that when "
"executing a simulation, we can know for certain that these two clocks will "
"trigger simultaneously."
msgstr ""
"再一次，我们看到在时钟间隔的有理表示。\ "
"这意味着在实践中，Modelica语言编译器可以确信这两个时钟\\ ``x``\\ 与\\ ``y``\\ "
"是相同的。\ "
"因为两者均是用可确切比较的整数量进行定义的。\ "
"也就是说，在执行仿真时，我们可以确信这两个时钟会同时触发。\ "

#: ../../source/behavior/discrete/sampling.rst:116
msgid ""
"Behind the scenes, the Modelica compiler can reason about these clocks.  It "
"knows that the ``x`` clock triggers every :math:`\\frac{1}{10}` of a second."
"  Using the information provided by the ``subSample`` operator the Modelica "
"compiler can therefore deduce that ``z`` triggers every "
":math:`\\frac{2}{10}` of a second. Conceptually, this means that ``z`` could"
" also have been defined as:"
msgstr ""
"Modelica语言编译器可以在幕后对这些时钟间的关系进行推理。\ "
"编译器知道每隔\\ :math:`\\frac{1}{10}`\\ 秒时钟\\ "
"``x``\\ 就会触发。\ "
"因此Modelica语言编译器可以使用\\ ``subSample``\\ 运算符所提供的信息推论出，每隔\\ "
":math:`\\frac{2}{10}`\\ 秒时钟\\ ``z``\\ 就会触发。\ "
"理论上，这意味着\\ ``z``\\ 也可以被定义为："

#: ../../source/behavior/discrete/sampling.rst:127
msgid ""
"But by defining ``z`` using the ``subSample`` operator and defining it with "
"respect to ``x`` we ensure that ``z`` is always triggering at half the "
"frequency of ``x`` regardless of how ``x`` is defined."
msgstr ""
"但通过使用\\ ``subSample``\\ 运算符相对\\ ``x``\\ 去进行对\\ ``z``\\ 的定义，我们可以确保无论\\ "
"``x``\\ 是如何定义的，\\ ``z``\\ 的触发频率总是\\ ``x``\\ 的一半。\ "

#: ../../source/behavior/discrete/sampling.rst:138
msgid "Again, we could have defined ``w`` directly using ``sample`` with:"
msgstr "同样，我们可以直接使用\\ ``sample``\\ 以对\\ ``w``\\ 进行如下定义："

#: ../../source/behavior/discrete/sampling.rst:148
msgid ""
"The synchronous clock features in Modelica are relatively new.  As such, "
"they are not yet supported by all Modelica compilers.  To learn more about "
"these synchronous features and their applications see [Elmqvist]_ and/or the"
" Modelica Specification, version 3.3 or later."
msgstr ""
"Modelica语言的同步时钟特性是相对较新。\ "
"因此，并非所有的Modelica语言编译器都支持这些特性。\ "
"要了解更多有关这些同步功能及其应用，可以参考\\"
" [Elmqvist]_\\ 以及／或者3.3版以后的Modelica规范。\ "

#: ../../source/behavior/discrete/sampling.rst:108
msgid ""
"If we wanted to create a clock that was exactly half as slow as ``x``, we "
"can use the ``subSample`` operator to accomplish this.  We see this in the "
"definition of ``z``:"
msgstr ""
"如果我们想创建一个正好是\\ ``x``\\ 两倍慢的时钟，那么我们可以使用\\ ``subSample``\\ 运算符来完成。\ "
"在\\ ``z``\\ "
"的定义里我们可以看到这种情况："

#: ../../source/behavior/discrete/sampling.rst:131
msgid ""
"In a similar way, we can define another clock, ``w`` that triggers 3 times "
"as frequently as ``x`` by using the ``superSample`` operator:"
msgstr "类似地，我们可以使用\\ ``superSample``\\ 运算符定义另一个触发频率为\\ ``x``\\ 3倍的时钟\\ ``w``\\ 。\ "

#: ../../source/behavior/discrete/sampling.rst:144
msgid ""
"But by using ``superSample``, we can ensure that ``w`` is always sampling "
"three times as fast as ``x`` and six times as fast as ``z`` (since ``z`` is "
"also defined with respect to ``x``)."
msgstr ""
"但使用\\ ``superSample``\\ 我们可以确保\\ ``w``\\ 的采样速度总是\\ ``x``\\ 的三倍、\\ ``z``\\ "
"的六倍（因为\\ ``z``\\ 也是基于\\ ``x``\\ 定义的）。\ "
