# 
msgid ""
msgstr ""
"Project-Id-Version: Modelica by Example 0.2.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-04-14 10:14-0400\n"
"PO-Revision-Date: 2014-09-22 22:20+0100\n"
"Last-Translator: Dongping Xie <dongping.xie.tud@gmail.com>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/behavior/discrete/decay.rst:4
msgid "State Event Handling"
msgstr "状态事件的处理"

#: ../../source/behavior/discrete/decay.rst:6
msgid ""
"Now that we have already introduced both :ref:`time events <cooling-"
"revisited>` and :ref:`state events <bouncing-ball>`, let's examine some "
"important complications associated with state events. Surprisingly, these "
"complications can be introduced by even simple models."
msgstr ""
"现在我们已经介绍了\\ :ref:`时间事件 <cooling-revisited>`\\ 和\\ :ref:`状态事件 <bouncing-"
"ball>`\\ ,让我们来看看与状态事件相关的一些重要的困难。出人意料的是，这些困难甚至会在简单的模型里出现。"

#: ../../source/behavior/discrete/decay.rst:13
msgid "Basic Decay Model"
msgstr "基本衰减模型"

#: ../../source/behavior/discrete/decay.rst:15
msgid "Consider the following almost trivial model:"
msgstr "请考虑以下简单得几近不值一提的模型："

#: ../../source/behavior/discrete/decay.rst:26
msgid ""
"Again, numerical issues creep in.  Even though mathematically it should not "
"be possible for the value of ``x`` to drop below zero, using numerical "
"integration techniques it is possible for small amounts of error to creep in"
" and drive ``x`` below zero.  When that happens, the ``sqrt(x)`` expression "
"generates a floating point exception and the simulation terminates."
msgstr ""
"再一次，数值问题混了进来。尽管在数学上\\ ``x``\\ 的值应该不可能的降到低于零，但在使用数值积分方法时，少量错误可能混入结果，使得\\ "
"``x``\\ 低于零。当发生这种情况时，\\ ``sqrt(x)``\\ 的表达式产生浮点异常，结果仿真终止。"

#: ../../source/behavior/discrete/decay.rst:34
msgid "Guard Expressions"
msgstr "保护表达式"

#: ../../source/behavior/discrete/decay.rst:36
msgid ""
"To prevent this, we might introduce an ``if`` expression to guard against "
"evaluating the square root of a negative number, like this:"
msgstr "为了避免这种情况，我们可以引入一个\\ ``if``\\ 表达式防止计算负数的平方根，如下："

#: ../../source/behavior/discrete/decay.rst:43
msgid "Simulating this model we get the following trajectory [#tol]_:"
msgstr "这个模型进行仿真，我们得到如下的轨迹\\ [#tol]_:"

#: ../../source/behavior/discrete/decay.rst:47
msgid ""
"Again, the simulation fails.  But why?  It fails for the same reason, a "
"numerical exception that results from taking the square root of a negative "
"number."
msgstr "再一次地，仿真失败。但是为什么呢？它出于相同的原因失败了：对负数的求平方根而导致的数值异常。"

#: ../../source/behavior/discrete/decay.rst:51
msgid ""
"Most people are quite puzzled when they see an error message about a "
"floating point exception like this (or, for example division by zero) after "
"they have introduced a guard expression as we have done.  They naturally "
"assume that there is no way that ``sqrt(x)`` can be evaluated if ``x`` is "
"less than zero.  **But this assumption is incorrect.**"
msgstr ""
"当大多数人看到像这样（或者例如被零除）的浮点异常错误信息时， 他们都非常困惑，毕竟他们都像我们一样写下了一个保护表达式。他们自然认为是当\\ "
"``x``\\ 小于零时\\ ``sqrt(x)``\\ 根本不可能会被计算。\\ **但这个假设是错误的。**"

#: ../../source/behavior/discrete/decay.rst:58
msgid "Events and Conditional Expressions"
msgstr "事件和条件表达式"

#: ../../source/behavior/discrete/decay.rst:63
msgid "Given the ``if`` expression:"
msgstr "若有如下\\ ``if``\\ 表达式："

#: ../../source/behavior/discrete/decay.rst:69
msgid ""
"it is entirely possible that ``sqrt`` will be called with a negative "
"argument.  The reason is related to the fact that this is a state event.  "
"Remember, the time at which a *time event* will occur is known in advance.  "
"But this is not the case for a state event.  In order to determine when the "
"event will occur, we have to search the solution trajectory to see when the "
"condition (*e.g.,* ``x>=0`` becomes false)."
msgstr ""
"\\ ``sqrt``\\ 被以负参数调用是完全有可能的。其原因与这是状态事件有关。请记住，\\ *时间事件*\\ "
"的发生时间是可以预知的。但是，状态事件则不然。 为了确定事件何时会发生，我们必须在解的轨迹寻找以确定条件（\\ *例如：*\\ ``x>=0``\\ "
"）何时为假。"

#: ../../source/behavior/discrete/decay.rst:77
msgid ""
"The important thing to understand is that **until the event occurs, the "
"behavior doesn't change**.  In other words, the two sides of this ``if`` "
"expression represent two types of behavior, ``der(x)=sqrt(x)`` and "
"``der(x)=0``.  Since ``x`` is initially greater than zero, the initial "
"behavior is ``der(x)=sqrt(x)``.  **The solver will continue using this "
"equation until it has determined the time of the event** represented by "
"``x>=0``.  In order to determine the time of that event, **it must go past "
"the point where the value of the conditional expression changes**.  This "
"means that while attempting to determine precisely when the condition "
"``x>=0`` changes from true to false, it will continue to use the equation "
"``der(x)=sqrt(x)`` even though ``x`` is negative."
msgstr ""
"要了解的重要一点是，\\ **直到事件发生时，行为都不会改变** \\ 。换句话说，这个\\ ``if``\\ 表达式的两个值代表了两种类型的行为，\\"
" ``der(x)=sqrt(x)``\\ 和\\ ``der(x)=0``\\ 。 由于\\ ``x``\\ 最初大于零，最初的行为便是\\ "
"``der(x)=sqrt(x)``\\ 。\\ **求解器将继续使用该方程，直到它确定了**\\ 由\\ ``x>=0``\\ 所表示的\\ "
"**事件发生的时间。**\\ 而为了确定该事件发生的时间，\\ **求解器必须越过条件表达式的值发生变化的点**\\ 。这意味着，在试图准确确定条件\\"
" ``x>=0``\\ 从真假的变化的时间这一过程中，虽然\\ ``x``\\ 已经为负，求解器仍会继续使用公式\\ "
"``der(x)=sqrt(x)``\\ 。"

#: ../../source/behavior/discrete/decay.rst:96
msgid ""
"This time spent trying and retrying integration steps can be saved thanks to"
" the fact that Modelica can extract a so-called \"zero crossing\" function "
"from the ``if`` expression.  This function is called a zero crossing "
"function because it is normally constructed to have a root at the point "
"where the event will occur.  For example, if we had the following ``if`` "
"expression:"
msgstr ""
"我们可以减少在尝试和重试积分步长中所花费的时间。这是得益于Modelica可以从\\ ``if``\\ 表达式提取出所谓的“过零”（zero-"
"crossing）函数。这些函数被之所以被称为过零函数，因为它通常被构造成为事件发生的位置有根存在的形式。例如，如果我们有以下\\ ``if``\\ "
"表达式："

#: ../../source/behavior/discrete/decay.rst:107
msgid ""
"The zero crossing function would be :math:`a-b`.  This function is chosen "
"because it changes from positive to negative precisely at the point where "
"``a>b``."
msgstr "这里的过零函数是\\ :math:`a-b`\\ 。之所以选择这个函数的原因是，它在\\ ``a>b``\\ 成立的时刻正好是由正转为负。"

#: ../../source/behavior/discrete/decay.rst:111
msgid "Recall our previous equation:"
msgstr "回想我们在前面的公式"

#: ../../source/behavior/discrete/decay.rst:117
msgid ""
"In this case, the zero crossing function is simply :math:`x` since the event"
" occurs when :math:`x` itself crosses zero."
msgstr "在此过零函数显然是\\ :math:`x`\\ 。这是因为事件在 \\ :math:`x`\\ 自己穿过零时发生。"

#: ../../source/behavior/discrete/decay.rst:120
msgid ""
"The Modelica compiler collects all the zero crossing functions in the model "
"for the integrator to use.  During integration, the integrator checks to see"
" if any of the zero crossing functions have changed sign.  If they have, it "
"uses the solution it computed during that step to interpolate the zero "
"crossing function to find the location, in time, of the root of the zero "
"crossing function and this is the point in time where the event occurs.  "
"This process is much more efficient because the root finding algorithms have"
" more information to help them identify to location of the root (information"
" like the derivative of the zero crossing function) and evaluation is very "
"cheap because it doesn't involve taking additional integration steps, only "
"evaluating the interpolation functions from the triggering integration step."
msgstr ""
"Modelica编译器收集在模型中所有的过零函数以给予积分器使用。在积分时，积分器检查是否有任何的过零函数变了号。如果这些过零函数变了号，那积分器便使用在该步长中计算出的解去内插过零函数，以此计算交叉函数变号的时刻。"
" "
"而这就是事件发生的时间点。这种方法非常有效率。因为求根算法可以使用更多的信息来帮助他们识别为根的位置（如过零函数的导数）。加上由于它不涉及采取额外的积分步骤，"
" 而仅从触发事件的积分步长开始计算内插函数的值，这种求解算法本身非常花销非常低。"

#: ../../source/behavior/discrete/decay.rst:138
msgid "Event Suppression"
msgstr "事件的抑制"

#: ../../source/behavior/discrete/decay.rst:140
msgid ""
"But after all this, it still isn't clear how to avoid the problems we saw in"
" the ``Decay1`` and ``Decay2`` models.  The answer is a special operator "
"called ``noEvent``.  The ``noEvent`` operator suppresses this special event "
"handling.  Instead, it does what most users expected would happen in the "
"first place, which is to evaluate the conditional expression for every value"
" of ``x``.  We can see the ``noEvent`` operator in action in the following "
"model:"
msgstr ""
"但经过这一切，如何避免我们在\\ ``Decay1``\\ 和\\ ``Decay2``\\ "
"模型中所看到的问题，仍然是不明确的。答案是一个特殊的操作符，\\ ``noEvent``\\ 。\\ ``noEvent``\\ "
"操作符抑制了这种特殊的事件处理方式。相反，它提供大多数用户一开始预期中的行为。也就是，在每一个\\ ``x``\\ "
"的取值都会进行条件表达式的计算。我们可以从下面的模型中看到\\ ``noEvent``\\ 操作符的作用："

#: ../../source/behavior/discrete/decay.rst:152
msgid "and the results can be seen here:"
msgstr "结果如下："

#: ../../source/behavior/discrete/decay.rst:157
msgid ""
"Now the simulation completes without any problem.  This is because the use "
"of ``noEvent`` ensures that ``sqrt(x)`` is never called with a negative "
"value of ``x``."
msgstr "现在仿真毫无问题地完成了。这是因为\\ ``noEvent``\\ 确保了\\ ``sqrt(x)``\\ 不会在\\ ``x``\\ 值为负时被调用。"

#: ../../source/behavior/discrete/decay.rst:161
msgid ""
"It might seems strange that we have to explicitly include the ``noEvent`` "
"operator in order to get what we consider the most intuitive behavior.  Why "
"not make the default behavior the most intuitive one?  The answer is "
"performance.  Using conditional expressions to generate events improves the "
"performance of the simulations by giving the solver clues about when to "
"expect abrupt changes in behavior.  Most of the time, this approach doesn't "
"cause any problem.  The examples we have presented in this chapter were "
"designed to highlight this issue, but they are not representative of most "
"cases.  For this reason, ``noEvent`` is not the default, but must be used "
"explicitly.  It should be noted that the ``noEvent`` operator should only be"
" used when there is a smooth transition in behavior, otherwise it can create"
" performance issues."
msgstr ""
"这似乎有点奇怪，我们必须显式地加入\\ ``noEvent``\\ "
"操作符才能得到我们认为最直观的行为。为什么不把默认行为设为最直观的一个呢？答案是性能原因。使用条件表达式生成事件提高了仿真的性能。因为这给予求解器何时要为行为突变做准备的相关线索。大多数时候，这种方法不会导致任何问题。我们在本章中提出了的例子都是为了强调这个问题，但这些例子并不能代表大多数情况。出于这个原因，\\"
" ``noEvent``\\ 不是默认的，而是必须显式地使用。但是应当指出的是， \\ ``noEvent``\\ "
"操作符应该只用于行为变化是平滑过渡的时候。否则它会带来性能问题。"

#: ../../source/behavior/discrete/decay.rst:176
msgid "Chattering"
msgstr "抖振"

#: ../../source/behavior/discrete/decay.rst:178
msgid ""
"There is a common effect known as \"chattering\" that you will run into "
"sooner or later with Modelica.  Consider the following model:"
msgstr "用Modelica语言时，你早晚会遇到一个被称为“抖动”（chattering）常见现象。考虑下面的模型："

#: ../../source/behavior/discrete/decay.rst:185
msgid "Simulating this model gives us the following results:"
msgstr "对此模型进行仿真给了我们如下结果："

#: ../../source/behavior/discrete/decay.rst:190
msgid ""
"This model is interesting because looking at it, one might assume the "
"equation:"
msgstr "这个模型很有趣。因为当大家看着它的时候，可能会假设："

#: ../../source/behavior/discrete/decay.rst:197
msgid "was equivalent to:"
msgstr "等价于："

#: ../../source/behavior/discrete/decay.rst:203
msgid ""
"After all, each branch in the ``if`` expression evaluates to ``-x`` and the "
"simulated result appears to be consistent with this assumption.  **But these"
" two equations are not equivalent**.  The difference, as we've already "
"discussed in this section, is that the one with the conditional expression "
"generates an event.  This means it will force the solver to truncate time "
"steps and restart the simulation."
msgstr ""
"毕竟，\\ ``if``\\ 表达式每个分支都是\\ ``-x``\\ 。而且，模拟结果似乎与这个假设是一致的。\\ "
"**但是，这两个等式是不等价的**\\ "
"。正如我们在本节已经讨论过的一样，不同点在于拥有条件表达式的等式会生成事件。这意味着它将迫使求解器截断时间步长，然后重新启动仿真。"

#: ../../source/behavior/discrete/decay.rst:211
msgid ""
"Let's take a step back and consider the mathematical solution to this "
"problem.  We would expect the solution trajectory for ``x`` to be a decaying"
" exponential that asymptotically approaches zero.  The problem is that zero "
"is exactly where the event happens.  Keep in mind that the numerical solver "
"will introduce small amounts of local error on each step when integrating "
"these equations.  As a result, the answer will (at least in general) not be "
"exactly zero.  Instead it will be slightly above or below zero."
msgstr ""
"让我们退一步，考虑这个问题的解析解。我们预计这个解的轨迹\\ ``x``\\ "
"是一个衰减的指数函数而且渐近趋近于零。问题在于，事件发生在零的位置上。请记住，数值求解器在对这些方程进行积分时，会在每一个步长带来少量的局部误差。其结果是，答案将（至少在通常情况下）不完全为零，相反，它会稍微高于或低于零。"
" "

#: ../../source/behavior/discrete/decay.rst:220
msgid ""
"This kind of model can introduce an effect known as \"chattering\". "
"Chattering is simply the degradation in simulation performance due to a "
"large number of events occurring that artificially shorten the time steps "
"taken by the solver.  What we see in the ``Decay4`` model is that the "
"solution asymptotically approaches a point where an event occurs.  This is "
"not uncommon, so it is important to watch out for such cases because they "
"can unnecessarily slow down simulations.  The important thing about the "
"``Decay4`` example is that it is physically realistic and has a smooth "
"solution, but still suffers from degraded simulation performance because of "
"the high frequency of events."
msgstr ""
"这种模型可能会引起一种被称为“抖动”的现象 "
"。抖动只不过是由于求解器在大量事件产生时过度地缩短时间步长所引致的仿真速度下降而已。我们在\\ ``Decay4``\\ "
"模式所看到的是，该解在渐进地接近事件发生的点。这种情况并不少见。因此，由于这种情况可能会不必要地减慢仿真的速度，我们必须密切注意。关于\\ "
"``Decay4``\\ 的重要一点是，虽然它不仅在物理中真实存在而且又有光滑的解，但其仿真性能仍会受到大量事件的影响。 "

#: ../../source/behavior/discrete/decay.rst:231
msgid ""
"One obvious solution would be to remove the ``if`` expression entirely from "
"this example.  It should be noted that while the ``Decay4`` model is a bit "
"contrived, because it has the **same** expression regardless of how the "
"conditional expression is evaluated, there are many physically realistic use"
" cases where a solution variable will converge asymptotically to the "
"location of a state event.  For example, we might have changed our "
"differential equation to be:"
msgstr ""
"一个明显的解决办法是把\\ ``if``\\ 表达式从这个例子中彻底删除。应当指出的是，虽然\\ ``Decay4``\\ "
"模型是有些许牵强，因为无论条件表达式的结果如何最终表达式仍然是\\ **不变的**\\ "
"，但是在许多物理上现实的情况里，解中的变量会渐近收敛到状态事件的位置。例如，我们可以把微分方程改写为： "

#: ../../source/behavior/discrete/decay.rst:243
msgid ""
"Here we have a different \"gain\" depending on the sign of ``x``.  These "
"kinds of cases do show up in realistic models.  So the question is, how do "
"we avoid the chattering that can occur in these cases."
msgstr ""
"在这里， 视\\ ``x``\\ 符号的正负，我们有不同的“增益”。这情况也出现在现实的模型里。因此问题是，在这些情况下我们如何避免可能发生的抖动。"

#: ../../source/behavior/discrete/decay.rst:247
msgid ""
"This is another case where the ``noEvent`` operator can help us out. Because"
" we know that this ``if`` expression doesn't introduce any abrupt changes in"
" behavior, we can wrap the conditional expression with the ``noEvent`` "
"operator as follows:"
msgstr ""
"这是另一种\\ "
"``noEvent``\\ 运算符有所助益的情况。因为我们知道，这\\ ``if``\\ 表达式并不引入任何行为上的突然变化，我们可以用\\ "
"``noEvent``\\ 操作符把条件表达式包裹起来。如下："

#: ../../source/behavior/discrete/decay.rst:345
msgid ""
"This model will not always fail.  The failure depends on how much "
"integration error is introduced and this, in turn, depends on the numerical "
"tolerances used."
msgstr "这个模型不会总会仿真失败。失败的出现取决于仿真引入多少积分误差。而积分误差则又取决于所使用的数值容差。"

#: ../../source/behavior/discrete/decay.rst:21
msgid ""
"If we attempt to simulate this model for 5 seconds, we find that the "
"simulation terminates after about 2 seconds with the following trajectory:"
msgstr "如果我们试图对此模型进行5秒的仿真，我们发现用仿真在大概2秒后停止。结果是如下的轨迹："

#: ../../source/behavior/discrete/decay.rst:61
msgid "The Role of Events in Behavior"
msgstr "事件在行为上的作用"

#: ../../source/behavior/discrete/decay.rst:90
msgid ""
"Most users initially assume that each time ``der(x)`` is evaluated, the "
"``if`` expression is evaluated (specifically the conditional expression in "
"the ``if`` expression).  Hopefully the previous paragraph has made it clear "
"that this is not the case."
msgstr ""
"大多数用户开始是认为每次\\ ``der(x)``\\ 被计算时，\\ ``if``\\ 表达式也会被计算（特别是在\\ ``if``\\ "
"表达式中的条件表达式） 。但愿前面的章节已经很清楚地阐释了，这并非事实。"

#: ../../source/behavior/discrete/decay.rst:256
msgid ""
"In doing so, we will get the same solution, but with better simulation "
"performance:"
msgstr ""
"这样做以后，我们会得到同样的解，但仿真性能更佳："

#: ../../source/behavior/discrete/decay.rst:263
msgid "Speed vs. Accuracy"
msgstr "速度与准确性"

#: ../../source/behavior/discrete/decay.rst:265
msgid ""
"Hopefully the discussion so far has made it clear why it is necessary to "
"suppress events in some cases.  But one might reasonably ask, why not skip "
"events and just evaluate conditional expressions all the time?  So let's "
"take some time to explore this question and explain why, on the whole, "
"associated events with conditional expressions is very good idea[#Belmon]_."
msgstr ""
"希望讨论至今大家已经明确，为什么在某些情况下有必要抑制事件的产生。不过，人们可能会问，为什么不直接跳过事件每次都计算条件表达式？那么，让我们花一些时间来探讨这个问题，并解释为何就整体而言把条件表达式与事件进行关联是个非常好的主意"
"\ [#Belmon]_\ 。"

#: ../../source/behavior/discrete/decay.rst:272
msgid ""
"Without event detection, the integrator will simply step right over events."
"  When this happens, the integrator will miss important changes in behavior "
"and this will have a significant impact on the accuracy of the simulation.  "
"This is because the accuracy of most integration routines is based on "
"assumptions about the continuity of the underlying function and its "
"derivatives.  If those assumptions are violated, we need to let the "
"integration routines know so they can account these changes in behavior."
msgstr ""
"如果没有事件检测，积分器只会直接跳过事件。而当这种情况发生时，积分器会错过重要的行为改变。这将会对仿真的准确性有显著的影响。这是因为大多数积分程序的准确性是基于对被积函数及其导数连续性的假设。倘若这些假设不再成立了，我们需要让积分程序知道这点。如此，积分器便可以考虑这些行为的改变。"

#: ../../source/behavior/discrete/decay.rst:281
msgid ""
"This is where events come in.  They force the integration to stop at the "
"point where a behavior change occurs and then restart again after the "
"behavior change has occurred.  The result is greater accuracy but at the "
"cost of slower simulations.  Let's look at a concrete example. Consider the "
"following simple Modelica model:"
msgstr ""
"这就到事件出场的时候了。事件强迫积分器在行为发生变化的时刻停止，然后在发生行为变化后的时点重新启动。其结果是在牺牲模拟速度的前提下获得更高的精度让我们看一个具体的例子。请考虑下面这个简单的Modelica模型："

#: ../../source/behavior/discrete/decay.rst:291
msgid ""
"Looking at this system, we can see that half the time the derivative of "
"``x`` will be ``2`` and the other half of the time the derivative of ``x`` "
"will be ``0``.  So over each of these cycles, the average derivative of "
"``x`` should be ``1``.  This means at the end of each cycle, ``x`` and ``y``"
" should be equal."
msgstr ""
"我们可以从这个系统看到在一半的时间里\\ ``x``\\ 的微分为\\``2``\\ 。而在另外一半时间里\\ ``x``\\ 的微分则为\\ "
"``0``\\ 。所以，在每一个周期中，\\``x``\\ 平均的微分应该是 ``1``\\ 。这意味着在每一个周期结束时，\\ ``x``\\ 和\\"
" ``y``应该相等。"

#: ../../source/behavior/discrete/decay.rst:297
msgid "If we simulate the ``WithEvents`` model, we get the following results:"
msgstr "倘若我们使用\\ ``WithEvents``\\ 对模型进行仿真，我们会得到如下的结果："

#: ../../source/behavior/discrete/decay.rst:302
msgid ""
"Note how, at the end of each cycle, the trajectories of ``x`` and ``y`` "
"meet.  This is a visual indication of the accuracy of the underlying "
"integration.  Even if we increase the frequency of the underlying cycle, we "
"see that this property holds true:"
msgstr ""
"请注意在每个周期结束时，\\ ``x``\\ 和\\ "
"``y``\ 的轨迹如何在一点汇合。这是潜在的积分精度的视觉指示。即使我们增加基本周期的频率，我们可以看到这个特点仍然存在： "

#: ../../source/behavior/discrete/decay.rst:310
msgid ""
"However, now let us consider the case where we use exactly the same "
"integration parameters but suppress events by using the ``noEvents`` "
"operator as follows:"
msgstr "不过，在使用完全相同的积分参数的情况下，现在让我们考虑通过\\ ``noEvents``\\ 操作符以抑制事件产生的情况："

#: ../../source/behavior/discrete/decay.rst:318
msgid ""
"In this case, the integrator is blind to the changes in behavior.  It does "
"its best to integrate accurately but without explicit knowledge of where the "
"behavior changes occur, it will blindly continue using the wrong value of "
"the derivative and extrapolate well beyond the change in behavior.  If we "
"simulate the ``WithNoEvents`` model, using the same integrator settings, we "
"can see how significantly different our results will be:"
msgstr ""
"在这种情况下，积分器不能得知行为变化。尽管它会尽量准确地进行积分，但如果积分器没有明确知道这些行为改变发生，那么它会继续盲目地使用错误的微分值，并在行为变化后很长时间继续进行外推。如果使用相同的积分器设置对使用了\\"
" ``WithNoEvents``\\ 的模型进行仿真，我们可以看到两者的结果有如何显著的不同： "

#: ../../source/behavior/discrete/decay.rst:329
msgid ""
"Note how quickly the integrator introduces some pretty significant error."
msgstr "请注意积分器何其迅速地引入了些非常显著的错误。"

#: ../../source/behavior/discrete/decay.rst:335
msgid ""
"The integration settings used in these examples were chosen to demonstrate "
"the impact that the ``noEvent`` operator can have on accuracy.  However, the"
" settings were admittedly chosen to accentuate these differences.  Using "
"more typical settings, the differences in the results probably would not "
"have been so dramatic.  Furthermore, the impact of using ``noEvent`` are "
"impossible to predict or quantify since they will vary significantly from "
"one solver to another.  But the underlying point is clear, using the "
"``noEvent`` operator can have a significant impact on accuracy simulation "
"results."
msgstr ""
"在这些例子中使用的积分器设定是为了说明\\ ``noEvent``\\ "
"操作符对精度可能造成的影响而设置的。然而，选择这些设置的目的确实是为了强调这些差异。如果使用更典型的设置，结果上的差异很可能不这么会引人注目。此外，使用\\"
" ``noEvent``\\ 的影响无法预测或量化。因为，这些影响在使用不用的求解器时会显著有所不同。但核心的问题名曲：使用\\ "
"``noEvent``\\ 操作符可能对仿真结果的精度有显著影响。"

#: ../../source/behavior/discrete/decay.rst:349
msgid ""
"A special thanks to Lionel Belmon for challenging my original discussion and"
" identifying several unsubstantiated assumptions on my part.  As a result, "
"this explanation is much better and includes results to support the "
"conclusions drawn."
msgstr ""
"特别感谢Lionel "
"Belmon对我原来讨论的质疑，以及找出了我的几个未经证实的假设。因为如此，现在的解释有了很大的改进，而且还加上了仿真结果以支持我的结论。"


