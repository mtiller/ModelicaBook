# 
msgid ""
msgstr ""
"Project-Id-Version: Modelica by Example 0.2.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-04-14 10:14-0400\n"
"PO-Revision-Date: 2014-10-03 22:20+0100\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dongping Xie <dongping.xie.tud@gmail.com>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/behavior/discrete/decay.rst:4
msgid "State Event Handling"
msgstr "状态事件的处理"

#: ../../source/behavior/discrete/decay.rst:6
msgid ""
"Now that we have already introduced both :ref:`time events <cooling-"
"revisited>` and :ref:`state events <bouncing-ball>`, let's examine some "
"important complications associated with state events. Surprisingly, these "
"complications can be introduced by even simple models."
msgstr ""
"我们已经介绍了\\ :ref:`时间事件 <cooling-revisited>`\\ 和\\ :ref:`状态事件 <bouncing-"
"ball>`\\ 。\ "
"现在让我们来看看与状态事件相关的一些重要的困难。\ "
"出人意料的是，这些困难甚至会在简单的模型里出现。\ "

#: ../../source/behavior/discrete/decay.rst:13
msgid "Basic Decay Model"
msgstr "基本衰减模型"

#: ../../source/behavior/discrete/decay.rst:15
msgid "Consider the following almost trivial model:"
msgstr "请考虑以下简单得几近不值一提的模型："

#: ../../source/behavior/discrete/decay.rst:26
msgid ""
"Again, numerical issues creep in.  Even though mathematically it should not "
"be possible for the value of ``x`` to drop below zero, using numerical "
"integration techniques it is possible for small amounts of error to creep in"
" and drive ``x`` below zero.  When that happens, the ``sqrt(x)`` expression "
"generates a floating point exception and the simulation terminates."
msgstr ""
"再一次，数值问题混了进来。\ "
"尽管在数学上\\ ``x``\\ 的值应该不可能的降到低于零，但在使用数值积分方法时，少量错误可能混入结果，使得\\ "
"``x``\\ 低于零。\ "
"发生这种情况时，\\ ``sqrt(x)``\\ 的表达式产生浮点异常，结果仿真终止。\ "

#: ../../source/behavior/discrete/decay.rst:34
msgid "Guard Expressions"
msgstr "保护表达式"

#: ../../source/behavior/discrete/decay.rst:36
msgid ""
"To prevent this, we might introduce an ``if`` expression to guard against "
"evaluating the square root of a negative number, like this:"
msgstr "为了避免这种情况，我们可以引入一个\\ ``if``\\ 表达式防止计算负数的平方根，如下："

#: ../../source/behavior/discrete/decay.rst:43
msgid "Simulating this model we get the following trajectory [#tol]_:"
msgstr "这个模型进行仿真，我们得到如下的轨迹\\ [#tol]_:"

#: ../../source/behavior/discrete/decay.rst:47
msgid ""
"Again, the simulation fails.  But why?  It fails for the same reason, a "
"numerical exception that results from taking the square root of a negative "
"number."
msgstr "再一次地，仿真失败。\ "
"但是为什么呢？它出于相同的原因失败了：对负数的求平方根而导致的数值异常。\ "

#: ../../source/behavior/discrete/decay.rst:51
msgid ""
"Most people are quite puzzled when they see an error message about a "
"floating point exception like this (or, for example division by zero) after "
"they have introduced a guard expression as we have done.  They naturally "
"assume that there is no way that ``sqrt(x)`` can be evaluated if ``x`` is "
"less than zero.  **But this assumption is incorrect.**"
msgstr ""
"大多数人在看到像这样（或者例如被零除）的浮点异常错误信息时，他们都非常困惑，毕竟他们都像我们一样写下了一个保护表达式。\ "
"他们自然认为是当\\ "
"``x``\\ 小于零时\\ ``sqrt(x)``\\ 根本不可能会被计算。\ "
"\\ **但这个假设是错误的。\ "
"**"

#: ../../source/behavior/discrete/decay.rst:58
msgid "Events and Conditional Expressions"
msgstr "事件和条件表达式"

#: ../../source/behavior/discrete/decay.rst:63
msgid "Given the ``if`` expression:"
msgstr "若有如下\\ ``if``\\ 表达式："

#: ../../source/behavior/discrete/decay.rst:69
msgid ""
"it is entirely possible that ``sqrt`` will be called with a negative "
"argument.  The reason is related to the fact that this is a state event.  "
"Remember, the time at which a *time event* will occur is known in advance.  "
"But this is not the case for a state event.  In order to determine when the "
"event will occur, we have to search the solution trajectory to see when the "
"condition (*e.g.,* ``x>=0`` becomes false)."
msgstr ""
"\\ ``sqrt``\\ 被以负参数调用是完全有可能的。\ "
"其原因与这是状态事件有关。\ "
"请记住，\\ *时间事件*\\ "
"的发生时间是可以预知的。\ "
"但是，状态事件则不然。\ "
"为了确定事件何时会发生，我们必须在解的轨迹寻找以确定条件（\例如：\\ ``x>=0``\\ "
"）何时为假。\ "

#: ../../source/behavior/discrete/decay.rst:77
msgid ""
"The important thing to understand is that **until the event occurs, the "
"behavior doesn't change**.  In other words, the two sides of this ``if`` "
"expression represent two types of behavior, ``der(x)=sqrt(x)`` and "
"``der(x)=0``.  Since ``x`` is initially greater than zero, the initial "
"behavior is ``der(x)=sqrt(x)``.  **The solver will continue using this "
"equation until it has determined the time of the event** represented by "
"``x>=0``.  In order to determine the time of that event, **it must go past "
"the point where the value of the conditional expression changes**.  This "
"means that while attempting to determine precisely when the condition "
"``x>=0`` changes from true to false, it will continue to use the equation "
"``der(x)=sqrt(x)`` even though ``x`` is negative."
msgstr ""
"要了解的重要一点是，\\ **直到事件发生时，行为都不会改变**\\ 。\ "
"换句话说，这个\\ ``if``\\ 表达式的两个值代表了两种类型的行为，\\"
" ``der(x)=sqrt(x)``\\ 和\\ ``der(x)=0``\\ 。\ "
"由于\\ ``x``\\ 最初大于零，最初的行为便是\\ "
"``der(x)=sqrt(x)``\\ 。\ "
"\\ **求解器将继续使用该方程，直到它确定了**\\ 由\\ ``x>=0``\\ 所表示的\\ "
"**事件发生的时间。\ "
"**\\ 而为了确定该事件发生的时间，\\ **求解器必须越过条件表达式的值发生变化的点**\\ 。\ "
"这意味着，在试图准确确定条件\\"
" ``x>=0``\\ 从真假的变化的时间这一过程中，虽然\\ ``x``\\ 已经为负，求解器仍会继续使用公式\\ "
"``der(x)=sqrt(x)``\\ 。\ "

#: ../../source/behavior/discrete/decay.rst:96
msgid ""
"This time spent trying and retrying integration steps can be saved thanks to"
" the fact that Modelica can extract a so-called \"zero crossing\" function "
"from the ``if`` expression.  This function is called a zero crossing "
"function because it is normally constructed to have a root at the point "
"where the event will occur.  For example, if we had the following ``if`` "
"expression:"
msgstr ""
"我们可以减少在尝试和重试积分步长中所花费的时间。\ "
"这是得益于Modelica可以从\\ ``if``\\ 表达式提取出所谓的“过零”（zero-"
"crossing）函数。\ "
"这些函数被之所以被称为过零函数，因为它通常被构造成为事件发生的位置有根存在的形式。\ "
"例如，如果我们有以下\\ ``if``\\ "
"表达式："

#: ../../source/behavior/discrete/decay.rst:107
msgid ""
"The zero crossing function would be :math:`a-b`.  This function is chosen "
"because it changes from positive to negative precisely at the point where "
"``a>b``."
msgstr "这里的过零函数是\\ :math:`a-b`\\ 。\ "
"之所以选择这个函数的原因是，它在\\ ``a>b``\\ 成立的时刻正好是由正转为负。\ "

#: ../../source/behavior/discrete/decay.rst:111
msgid "Recall our previous equation:"
msgstr "回想我们在前面的公式"

#: ../../source/behavior/discrete/decay.rst:117
msgid ""
"In this case, the zero crossing function is simply :math:`x` since the event"
" occurs when :math:`x` itself crosses zero."
msgstr "在此过零函数显然是\\ :math:`x`\\ 。\ "
"这是因为事件在\\ :math:`x`\\ 自己穿过零时发生。\ "

#: ../../source/behavior/discrete/decay.rst:120
msgid ""
"The Modelica compiler collects all the zero crossing functions in the model "
"for the integrator to use.  During integration, the integrator checks to see"
" if any of the zero crossing functions have changed sign.  If they have, it "
"uses the solution it computed during that step to interpolate the zero "
"crossing function to find the location, in time, of the root of the zero "
"crossing function and this is the point in time where the event occurs.  "
"This process is much more efficient because the root finding algorithms have"
" more information to help them identify to location of the root (information"
" like the derivative of the zero crossing function) and evaluation is very "
"cheap because it doesn't involve taking additional integration steps, only "
"evaluating the interpolation functions from the triggering integration step."
msgstr ""
"Modelica编译器收集在模型中所有的过零函数以给予积分器使用。\ "
"在积分时，积分器检查是否有任何的过零函数变了号。\ "
"如果这些过零函数变了号，那积分器便使用在该步长中计算出的解去内插过零函数，以此计算交叉函数变号的时刻。\ "
" "
"而这就是事件发生的时间点。\ "
"这种方法非常有效率。\ "
"因为求根算法可以使用更多的信息来帮助他们识别为根的位置（如过零函数的导数）。\ "
"加上由于它不涉及采取额外的积分步骤，"
" 而仅从触发事件的积分步长开始计算内插函数的值，这种求解算法本身非常花销非常低。\ "

#: ../../source/behavior/discrete/decay.rst:138
msgid "Event Suppression"
msgstr "事件的抑制"

#: ../../source/behavior/discrete/decay.rst:140
msgid ""
"But after all this, it still isn't clear how to avoid the problems we saw in"
" the ``Decay1`` and ``Decay2`` models.  The answer is a special operator "
"called ``noEvent``.  The ``noEvent`` operator suppresses this special event "
"handling.  Instead, it does what most users expected would happen in the "
"first place, which is to evaluate the conditional expression for every value"
" of ``x``.  We can see the ``noEvent`` operator in action in the following "
"model:"
msgstr ""
"但经过这一切，如何避免我们在\\ ``Decay1``\\ 和\\ ``Decay2``\\ "
"模型中所看到的问题，仍然是不明确的。\ "
"答案是一个特殊的操作符，\\ ``noEvent``\\ 。\ "
"\\ ``noEvent``\\ "
"操作符抑制了这种特殊的事件处理方式。\ "
"相反，它提供大多数用户一开始预期中的行为。\ "
"也就是，在每一个\\ ``x``\\ "
"的取值都会进行条件表达式的计算。\ "
"我们可以从下面的模型中看到\\ ``noEvent``\\ 操作符的作用："

#: ../../source/behavior/discrete/decay.rst:152
msgid "and the results can be seen here:"
msgstr "结果如下："

#: ../../source/behavior/discrete/decay.rst:157
msgid ""
"Now the simulation completes without any problem.  This is because the use "
"of ``noEvent`` ensures that ``sqrt(x)`` is never called with a negative "
"value of ``x``."
msgstr "现在仿真毫无问题地完成了。\ "
"这是因为\\ ``noEvent``\\ 确保了\\ ``sqrt(x)``\\ 不会在\\ ``x``\\ 值为负时被调用。\ "

#: ../../source/behavior/discrete/decay.rst:161
msgid ""
"It might seems strange that we have to explicitly include the ``noEvent`` "
"operator in order to get what we consider the most intuitive behavior.  Why "
"not make the default behavior the most intuitive one?  The answer is "
"performance.  Using conditional expressions to generate events improves the "
"performance of the simulations by giving the solver clues about when to "
"expect abrupt changes in behavior.  Most of the time, this approach doesn't "
"cause any problem.  The examples we have presented in this chapter were "
"designed to highlight this issue, but they are not representative of most "
"cases.  For this reason, ``noEvent`` is not the default, but must be used "
"explicitly.  It should be noted that the ``noEvent`` operator should only be"
" used when there is a smooth transition in behavior, otherwise it can create"
" performance issues."
msgstr ""
"这似乎有点奇怪，我们必须显式地加入\\ ``noEvent``\\ "
"操作符才能得到我们认为最直观的行为。\ "
"为什么不把默认行为设为最直观的一个呢？答案是性能原因。\ "
"使用条件表达式生成事件提高了仿真的性能。\ "
"因为这给予求解器何时要为行为突变做准备的相关线索。\ "
"大多数时候，这种方法不会导致任何问题。\ "
"我们在本章中提出了的例子都是为了强调这个问题，但这些例子并不能代表大多数情况。\ "
"出于这个原因，\\"
" ``noEvent``\\ 不是默认的，而是必须显式地使用。\ "
"但是应当指出的是，\\ ``noEvent``\\ "
"操作符应该只用于行为变化是平滑过渡的时候。\ "
"否则它会带来性能问题。\ "

#: ../../source/behavior/discrete/decay.rst:176
msgid "Chattering"
msgstr "抖振"

#: ../../source/behavior/discrete/decay.rst:178
msgid ""
"There is a common effect known as \"chattering\" that you will run into "
"sooner or later with Modelica.  Consider the following model:"
msgstr "用Modelica语言时，你早晚会遇到一个被称为“抖动”（chattering）常见现象。\ "
"考虑下面的模型："

#: ../../source/behavior/discrete/decay.rst:199
msgid "Simulating this model gives us the following results:"
msgstr "对此模型进行仿真给了我们如下结果："

#: ../../source/behavior/discrete/decay.rst:333
msgid ""
"This model will not always fail.  The failure depends on how much "
"integration error is introduced and this, in turn, depends on the numerical "
"tolerances used."
msgstr "这个模型不会总会仿真失败。\ "
"失败的出现取决于仿真引入多少积分误差。\ "
"而积分误差则又取决于所使用的数值容差。\ "

#: ../../source/behavior/discrete/decay.rst:21
msgid ""
"If we attempt to simulate this model for 5 seconds, we find that the "
"simulation terminates after about 2 seconds with the following trajectory:"
msgstr "如果试图对此模型进行5秒的仿真，我们会发现仿真大概用2秒后就停止了。\ "
"结果是如下的轨迹："

#: ../../source/behavior/discrete/decay.rst:61
msgid "The Role of Events in Behavior"
msgstr "事件在行为上的作用"

#: ../../source/behavior/discrete/decay.rst:90
msgid ""
"Most users initially assume that each time ``der(x)`` is evaluated, the "
"``if`` expression is evaluated (specifically the conditional expression in "
"the ``if`` expression).  Hopefully the previous paragraph has made it clear "
"that this is not the case."
msgstr ""
"大多数用户开始是认为每次\\ ``der(x)``\\ 被计算时，\\ ``if``\\ 表达式也会被计算（特别是在\\ ``if``\\ "
"表达式中的条件表达式）。\ "
"但愿前面的章节已经很清楚地阐释了，这并非事实。\ "

#: ../../source/behavior/discrete/decay.rst:251
msgid "Speed vs. Accuracy"
msgstr "速度与准确性"

#: ../../source/behavior/discrete/decay.rst:260
msgid ""
"Without event detection, the integrator will simply step right over events."
"  When this happens, the integrator will miss important changes in behavior "
"and this will have a significant impact on the accuracy of the simulation.  "
"This is because the accuracy of most integration routines is based on "
"assumptions about the continuity of the underlying function and its "
"derivatives.  If those assumptions are violated, we need to let the "
"integration routines know so they can account these changes in behavior."
msgstr ""
"如果没有事件检测，积分器只会直接跳过事件。\ "
"而如果这种情况发生，积分器会错过重要的行为改变。\ "
"这将会对仿真的准确性有显著的影响。\ "
"这是因为大多数积分程序的准确性是基于对被积函数及其导数连续性的假设。\ "
"倘若这些假设不再成立了，我们需要让积分程序知道这点。\ "
"如此，积分器便可以考虑这些行为的改变。\ "

#: ../../source/behavior/discrete/decay.rst:269
msgid ""
"This is where events come in.  They force the integration to stop at the "
"point where a behavior change occurs and then restart again after the "
"behavior change has occurred.  The result is greater accuracy but at the "
"cost of slower simulations.  Let's look at a concrete example. Consider the "
"following simple Modelica model:"
msgstr ""
"这就到事件出场的时候了。\ "
"事件强迫积分器在行为发生变化的时刻停止，然后在发生行为变化后的时点重新启动。\ "
"其结果是在牺牲模拟速度的前提下获得更高的精度让我们看一个具体的例子。\ "
"请考虑下面这个简单的Modelica模型："

#: ../../source/behavior/discrete/decay.rst:279
msgid ""
"Looking at this system, we can see that half the time the derivative of "
"``x`` will be ``2`` and the other half of the time the derivative of ``x`` "
"will be ``0``.  So over each of these cycles, the average derivative of "
"``x`` should be ``1``.  This means at the end of each cycle, ``x`` and ``y``"
" should be equal."
msgstr ""
"我们可以从这个系统看到在一半的时间里\\ ``x``\\ 的微分为\\ ``2``\\ 。\ "
"而在另外一半时间里\\ ``x``\\ 的微分则为\\ ``0``\\ 。\ "
"所以，在每一个周期中，\\``x``\\ 平均的微分应该是\ ``1``\\ 。\ "
"这意味着在每一个周期结束时，\\ ``x``\\ 和\\"
" ``y``应该相等。\ "

#: ../../source/behavior/discrete/decay.rst:285
msgid "If we simulate the ``WithEvents`` model, we get the following results:"
msgstr "倘若我们使用\\ ``WithEvents``\\ 对模型进行仿真，我们会得到如下的结果："

#: ../../source/behavior/discrete/decay.rst:290
msgid ""
"Note how, at the end of each cycle, the trajectories of ``x`` and ``y`` "
"meet.  This is a visual indication of the accuracy of the underlying "
"integration.  Even if we increase the frequency of the underlying cycle, we "
"see that this property holds true:"
msgstr ""
"请注意在每个周期结束时，\\ ``x``\\ 和\\ ``y``\\ "
"的轨迹如何在一点汇合。\ "
"这是潜在的积分精度的视觉指示。\ "
"即使我们增加基本周期的频率，我们可以看到这个特点仍然存在："

#: ../../source/behavior/discrete/decay.rst:298
msgid ""
"However, now let us consider the case where we use exactly the same "
"integration parameters but suppress events by using the ``noEvents`` "
"operator as follows:"
msgstr "不过，在使用完全相同的积分参数的情况下，现在让我们考虑通过\\ ``noEvents``\\ 操作符以抑制事件产生的情况："

#: ../../source/behavior/discrete/decay.rst:306
msgid ""
"In this case, the integrator is blind to the changes in behavior.  It does "
"its best to integrate accurately but without explicit knowledge of where the"
" behavior changes occur, it will blindly continue using the wrong value of "
"the derivative and extrapolate well beyond the change in behavior.  If we "
"simulate the ``WithNoEvents`` model, using the same integrator settings, we "
"can see how significantly different our results will be:"
msgstr ""
"在这种情况下，积分器不能得知行为变化。\ "
"尽管它会尽量准确地进行积分，但如果积分器没有明确知道这些行为改变发生，那么它会继续盲目地使用错误的微分值，并在行为变化后很长时间继续进行外推。\ "
"如果使用相同的积分器设置对使用了\\"
" ``WithNoEvents``\\ 的模型进行仿真，我们可以看到两者的结果有如何显著的不同： "

#: ../../source/behavior/discrete/decay.rst:317
msgid ""
"Note how quickly the integrator introduces some pretty significant error."
msgstr "请注意积分器何其迅速地引入了些非常显著的错误。\ "

#: ../../source/behavior/discrete/decay.rst:323
msgid ""
"The integration settings used in these examples were chosen to demonstrate "
"the impact that the ``noEvent`` operator can have on accuracy.  However, the"
" settings were admittedly chosen to accentuate these differences.  Using "
"more typical settings, the differences in the results probably would not "
"have been so dramatic.  Furthermore, the impact of using ``noEvent`` are "
"impossible to predict or quantify since they will vary significantly from "
"one solver to another.  But the underlying point is clear, using the "
"``noEvent`` operator can have a significant impact on accuracy simulation "
"results."
msgstr ""
"在这些例子中使用的积分器设定是为了说明\\ ``noEvent``\\ "
"操作符对精度可能造成的影响而设置的。\ "
"然而，选择这些设置的目的确实是为了强调这些差异。\ "
"如果使用更典型的设置，结果上的差异很可能不这么会引人注目。\ "
"此外，使用\\ ``noEvent``\\ 的影响无法预测或量化。\ "
"因为，这些影响在使用不用的求解器时会显著有所不同。\ "
"但核心的问题名曲：使用\\ "
"``noEvent``\\ 操作符可能对仿真结果的精度有显著影响。\ "

#: ../../source/behavior/discrete/decay.rst:337
msgid ""
"A special thanks to Lionel Belmon for challenging my original discussion and"
" identifying several unsubstantiated assumptions on my part.  As a result, "
"this explanation is much better and includes results to support the "
"conclusions drawn."
msgstr ""
"特别感谢Lionel "
"Belmon对我原来讨论的质疑，以及找出了我的几个未经证实的假设。\ "
"因为如此，现在的解释有了很大的改进，而且还加上了仿真结果以支持我的结论。\ "

#: ../../source/behavior/discrete/decay.rst:185
msgid ""
"Effectively, the behavior of this model is that for any initial value of "
"``x``, it will progress linearly toward 1.  Mathematically speaking, once "
"the value of ``x`` gets to 1, it should just stay there.  This is because "
"any deviation away from 1, either greater than or less than, will "
"immediately cause it to go back to 1."
msgstr ""
"实际上，这个模型的行为是，对\ ``x``\ 的任何初值，状态\ ``x``\ 都会线性渐近到1。\ "
"在数学上讲，一旦\ ``x``\ 值到达1，它的值便不再会变更。\ "
"因为，任何从1的偏移，不论正负，都将立即导致它返回到1。\ "

#: ../../source/behavior/discrete/decay.rst:191
msgid ""
"But we will not be solving these equations in a strictly mathematical way.  "
"We'll be using floating point representations and using numerical "
"integrators. As such, we have limited precision and integration error to "
"content with.  The net effect will be that the trajectory of ``x`` will not "
"remain exactly 1 but will deviate slightly above and below.  Each time this "
"happens, it will generate an event."
msgstr ""
"但我们不会用一个严格的数学方法去求解这些方程。\ "
"相反，我们将使用浮点数表示法表示变量，而用数值积分器计算结果。\ "
"因此，我们只能满足于有限的精度和积分误差。\ "
"这些误差的净效应是，\ ``x``\ 的轨迹不会完全保持1而将偏离略微上方和下方。\ "
"而每次发生这种情况都会生成一个事件。\ "

#: ../../source/behavior/discrete/decay.rst:203
msgid ""
"This kind of model can introduce an effect known as \"chattering\". "
"Chattering is simply the degradation in simulation performance due to a "
"large number of events occurring that artificially shorten the time steps "
"taken by the solver.  The impact on simulation performance is clear if we "
"look at the CPU time taken during the simulation.  It starts to rise "
"dramatically once ``x`` is close to 1.  This is because behind the scenes "
"the events are causing lots of very small time steps which dramatically "
"increases the number of computations being performed.  The important thing "
"about the ``WithChatter`` example is that it has a seemingly obvious "
"mathematical solutions but still suffers from degraded simulation "
"performance because of the high frequency of events."
msgstr ""
"这种模型可能会引起一种被称为“抖动”的现象。\ "
"抖动其实只是由于求解器在大量事件产生时，由于过度地缩短时间步长所引致的仿真速度下降。\ "
"如果我们观察在仿真过程中所使用的CPU时间，抖动对仿真性能的影响其实是显而易见的。\ "
"当\ ``x``\ 接近1时，CPU时间便开始急剧上升。\ "
"原因是在幕后事件造成大量的非常小的时间步长而显着地增加所执行的计算的数量。\ "
"这是因为在幕后，事件造成大量非常小的时间步长，从而让所执行的计算量也急剧增加。\ "
"\ ``WithChatter``\ 这个例子之所以重要，在于本例有一个显而易见的解析解，\ "
"但即使如此，本例仍然受到事件的高频率产生而减低了仿真性能。\ "


#: ../../source/behavior/discrete/decay.rst:216
msgid ""
"This is another case where the ``noEvent`` operator can help us out. We can "
"suppress the events being generated by the conditional expression by using "
"the ``noEvent`` operator as follows:"
msgstr ""
"这是另一种\\ ``noEvent``\\ 运算符有所助益的情况。\ "
"因为我们知道，这\\ ``if``\\ 表达式并不引入任何行为上的突然变化，\ "
"我们可以用\\ ``noEvent``\\ 操作符把条件表达式包裹起来。\ "
"如下："

#: ../../source/behavior/discrete/decay.rst:224
msgid ""
"In doing so, we will get approximately the same solution, but with better "
"simulation performance:"
msgstr "这样做以后，我们会得到几乎相同的解，但仿真性能更佳："

#: ../../source/behavior/discrete/decay.rst:229
msgid ""
"Note how there is no perceptible change in the slope of the CPU usage before"
" and after ``x`` arrives at 1.  Contrast this with the significant "
"difference seen in the case of ``WithChatter``."
msgstr ""
"请注意\ ``x``\ 到达1的前后，CPU占用率的斜率没有明显的变化。\ "
"这与在\ ``WithChatter``\ 的情况对比下有着显著差异。\ "

#: ../../source/behavior/discrete/decay.rst:233
msgid ""
"In reality, equations like this are uncommon.  In this case, we've used an "
"extreme case in an attempt to clearly show the impact of chattering.  The "
"behavior being described here is not particularly realistic or physical.  In"
" this case, we've exaggerated the effect to clearly demonstrate the impact "
"on simulation performance."
msgstr ""
"在现实中，像这样的方程是罕见的。\ "
"在本例中，我们使用一个极端情况试图清楚地显示抖动所带来的影响。\ "
"这里所描述的行为并不是特别现实或物理的。\ "
"在这种情况下，我们夸大了抖动产生的效果以清楚地表明仿真性能受到的影响。\ "

#: ../../source/behavior/discrete/decay.rst:239
msgid ""
"More typical examples of chattering in the real world will feature a "
"conditional expression that sits at some stable point (``Decay2`` is a good "
"example).  In such cases, chattering occurs because the system tends to "
"naturally settle at or near the point where the conditional expression "
"occurs.  But because of precision and numerical considerations, the event "
"associated with the conditional expression is frequently triggered.  The "
"effect is exacerbated in cases where there are many components in the system"
" all sitting at or near such equilibrium points."
msgstr ""
"抖动在现实世界中的更典型的例子包括，在某个稳定点周围生效的条件表达式（\ ``Decay2``\ 就是一个很好的例子）。\ "
"在这种情况下就会发生抖动，因为该系统往往会自然稳定到其中在条件表达式的发生点或者其附近。\ "
"而由于精确度和数值计算上的考虑，与条件式相关联的事件会被频繁触发。\ "
"倘若系统有许多部件在这样的平衡点附近，这个效果便会被加剧了。\ "

#: ../../source/behavior/discrete/decay.rst:253
msgid ""
"Hopefully the discussion so far has made it clear why it is necessary to "
"suppress events in some cases.  But one might reasonably ask, why not skip "
"events and just evaluate conditional expressions all the time?  So let's "
"take some time to explore this question and explain why, on the whole, "
"associating events with conditional expressions is very good idea "
"[#Belmon]_."
msgstr ""
"希望讨论至今大家已经清楚，为什么在某些情况下有必要抑制事件的产生。\ "
"不过，大家可能会问，为什么不直接跳过事件，每次都计算条件表达式？\ "
"那么，让我们花一些时间来探讨这个问题，\ "
"并解释为何就整体而言把条件表达式与事件进行关联是个非常好的主意\\ [#Belmon]_\\ 。\ "

