# 
msgid ""
msgstr ""
"Project-Id-Version: Modelica by Example 0.2.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-04-14 10:14-0400\n"
"PO-Revision-Date: 2014-10-09 23:20+0100\n"
"Last-Translator: Dongping Xie <dongping.xie.tud@gmail.com>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/behavior/discrete/hysteresis.rst:4
msgid "Hysteresis"
msgstr "滞回"

#: ../../source/behavior/discrete/hysteresis.rst:6
msgid ""
"In this section, we'll discuss the topic of hysteresis.  This is an "
"important concept to understand for certain types of modeling.  Recall in "
"our previous discussion of :ref:`state-events` we saw cases where chattering"
" occurred.  In those cases, we were able to use the ``noEvent`` operator to "
"address the issue because the chattering was purely a response to numerical "
"noise and not triggered by abrupt changes in behavior."
msgstr ""
"在本节中，我们将讨论滞回。\ "
"这是为了理解某些特定的建模类型所必须的一个重要概念。\ "
"还记得前面在\ :ref:`state-events`\ 的讨论中，我们看到了抖动的例子。\ "
"在那些例子里，我们可以使用\ ``noEvent``\ 运算符来解决抖动的问题。\ "
"这是因为前述抖动的情况纯粹是由数值噪音产生的。\ "
"那与行为的突然变化毫无关系。\ "

#: ../../source/behavior/discrete/hysteresis.rst:14
msgid ""
"In this section, we will consider a slightly more extreme case. Consider the"
" following model:"
msgstr ""
"在本节中，我们将考虑一个稍微极端的例子。\ "
"请考虑以下模型："

#: ../../source/behavior/discrete/hysteresis.rst:21
msgid "If we simulate this model, we get the following results:"
msgstr "倘若我们对模型进行仿真，便会得到下列结果："

#: ../../source/behavior/discrete/hysteresis.rst:26
msgid ""
"However, the simulation that yields these results takes a very long time to "
"complete.  The reason for such poor simulation performance can be better "
"understood by looking at the heater output during the simulation:"
msgstr ""
"然而，从开始仿真到产生上述结果却需要很长的时间。\ "
"读者可以通过观察加热器在仿真中的输出，以进一步了解性能不佳的原因。\ "

#: ../../source/behavior/discrete/hysteresis.rst:53
msgid ""
"The tricky thing about modeling hysteresis is that it is \"stateful\". "
"Determining the behavior of the system depends on what happened in the past."
"  For this reason, we cannot simply use ``if`` statements.  The reason is "
"that ``if`` statements consider only the current state of the system, "
"nothing else.  To implement hysteresis, we need to use ``when`` statements."
"  Consider the following model:"
msgstr ""
"要建模滞回必须考虑一个棘手的问题，也就是滞回是“有状态的”。\ "
"那么要确定系统的行为我们必须知道系统的历史。\ "
"因此，我们并不能简单地使用\ ``if``\ 语句。\ "
"其原因是\ ``if``\ 语句除去考虑系统的当前状态外，并不会考虑别的因素。\ "
"为了实现滞回，我们需要用到\ ``when``\ 语句。\ "
"考虑下列模型："

#: ../../source/behavior/discrete/hysteresis.rst:64
msgid ""
"Examining the ``when`` statements, we see that the system only responds when"
" ``T>Tbar+1`` becomes true or ``T<Tbar-1`` becomes true.  **Note that "
"nothing happens when these expressions become false**.  This is why an "
"``if`` statement won't work.  With an ``if`` statement or ``if`` expression,"
" the behavior changes whenever the conditional expression changes.  But with"
" a ``when`` statement, the statements in the ``when`` statement become "
"active **only** when the condition becomes true.  If we simulate this model "
"and look at the temperature, we see that it stays within the hysteresis band"
" of our desired temperature."
msgstr ""
"仔细观察上面的\ ``when``\ 语句，我们可以知道仅当"
" \ ``T>Tbar+1``\  或者 \ ``T<Tbar-1``\  变为真时，系统才会有响应。\ "
"\ **请注意，若上述表达式变为假，系统并不会有响应**\ 。\ "
"这就是为何\ ``if``\ 语句在此并不适用。\ "
"使用\ ``if``\ 语句或者\ ``if``\ 表达式时，只要条件表达式的值发生了变化，"
"系统的行为就会改变。\ "
"而使用\ ``when``\ 语句时，\ **仅仅**\ 当条件为真时，\ ``when``\ 语句内的代码才会被激活。\ "
"如果我们对该模型进行仿真并观察其温度，那么我们会看到温度保持在期望温度的滞环带内。\ "

#: ../../source/behavior/discrete/hysteresis.rst:77
msgid ""
"More importantly, if we look at the heat output from the system, we see "
"that, unlike our previous example, some time elapses between the heater "
"turning on and the heater turning off."
msgstr ""
"更重要的是，我们观察系统输出的热量时便会发现，与先前例子不同的是，解热器的开与关之间有些许的时间间隔。\ "

#: ../../source/behavior/discrete/hysteresis.rst:84
msgid ""
"The logic for implementing hysteresis can be made slightly more explicit by "
"using an ``algorithm`` section (as previous discussed during our discussion "
"on :ref:`speed estimation techniques <pulse-counting>`)."
msgstr ""
"通过使用\ ``algorithm``\ 区域可以让实现滞回的逻辑变得更显然（正如我们前面在\ :ref:`\ 速度估测方法\ <pulse-counting>`\ 的讨论一样）。\ "

#: ../../source/behavior/discrete/hysteresis.rst:94
msgid ""
"Note how the two conditional expressions have been broken into two separate "
"``when`` statements.  This makes it explicitly clear what causes the heat to"
" be turned on and off.  These ``when`` statements were placed in an "
"``algorithm`` section because they both assign to the same variable, "
"``heat``."
msgstr ""
"注意这两个条件表达式是如何被分成两个独立的\ ``when``\ 语句的。\ "
"如此这般，热源开闭的缘由也就显而易见了。\ "
"由于这两个\ ``when``\ 语句都是对同一个变量\ ``heat``\ 进行赋值，"
"因此两句都是在\ ``algorithm``\ 区域里定义的。\ "


#: ../../source/behavior/discrete/hysteresis.rst:34
msgid ""
"What you see is that after around 0.2 seconds, the heater is constantly "
"turning on and off.  This happens so frequently, in fact, that you would "
"have to zoom in quite a bit on the plot to see the transitions.  With normal"
" scaling, there are so many transitions that the results resemble a filled "
"rectangle."
msgstr ""
"你会看到，在0.2秒左右之后，加热器不断地打开和关闭。\ "
"这发生得如此频繁，以致于你要将图放大多次后才能看到这些转换。\ "
"大量的状态转换让结果在正常比例下像一个填充满了的矩形。\ "

#: ../../source/behavior/discrete/hysteresis.rst:40
msgid ""
"This is actually a real problem in control systems.  If you look carefully "
"at the way the furnace works in your own home, you will see that it does not"
" turn on and off constantly as the temperature goes above and below the "
"desired room temperature you have specified. Instead, it waits until the "
"temperature gets some specified amount above or below the desired "
"temperature before acting."
msgstr ""
"这实际上是在控制系统中的现实问题。\ "
"如果你仔细观察家里电炉的工作方式便会发现，电炉不会在高于或低于设定的室内温度时就不停地打开关闭。\ "
"相反，电炉会等到温度变得高于或低于设定温度一定额度后，才会开始作出反应。\ "

#: ../../source/behavior/discrete/hysteresis.rst:47
msgid ""
"This \"band\" that is introduced around the desired temperature is called "
"hysteresis.  The problem with the ``ChatteringControl`` model is that it "
"doesn't have any hysteresis.  Instead, it is constantly turning the heater "
"off and on in response to miniscule changes in temperature."
msgstr ""
"围绕着设定温度周围引入的“带”就叫做滞回。\ "
"\ ``ChatteringControl``\ 模型的问题就在于它并没有任何滞回。\ "
"相反，该模型不停地开关加热器以响应微乎其微的温度变化。\ "
