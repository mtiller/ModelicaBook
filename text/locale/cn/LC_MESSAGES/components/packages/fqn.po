#
msgid ""
msgstr ""
"Project-Id-Version: Modelica by Example 0.2.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-04-14 10:14-0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: Dongping Xie <dongping.xie.tud@gmail.com>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/components/packages/fqn.rst:4
msgid "Referencing Package Contents"
msgstr "引用包内内容"

#: ../../source/components/packages/fqn.rst:6
msgid ""
"Now that we've covered :ref:`organizing-content`, we'll discuss how to "
"access that content across different packages.  Let's consider the following"
" example:"
msgstr "现在，我们已经介绍了\ :ref:`organizing-content`\ 。\ "
"下面我们将开始讨论如何访问不同包里的内容。\ "
"让我们观察以下例子："

#: ../../source/components/packages/fqn.rst:13
msgid "As we learned in the previous section, the very first line,"
msgstr "正如我们在上节里知道的，第一行："

#: ../../source/components/packages/fqn.rst:19
msgid ""
"tells us that the ``RLC`` model is contained within the "
"``ModelicaByExample.PackageExamples`` package.  As with the previous "
"example, we are going to make use of the Modelica ``package`` system to "
"allow us to avoid defining types directly in our model.  In this way, we "
"define the types once in one package and then we can reuse them in many "
"places simply by referencing them."
msgstr ""
"告诉我们\ ``RLC``\ 模型是\ ``ModelicaByExample.PackageExamples``\ "
"包的一部分。\ "
"正如前面的例子一样，我们将利用Modelica的\ ``package``\ "
"系统，以避免直接在模型中定义类型。\ "
"这样一来，我们一旦在包内定义了类型，就可以简单地通过引用而在不同的地方而对类型进行重用。\ "

#: ../../source/components/packages/fqn.rst:26
msgid ""
"Unlike the previous example in this chapter, we don't define any types in "
"this example.  Instead, we rely on types that are defined in the :ref:`msl`."
"  The :ref:`msl` contains many useful types, models, constants, *etc*.  For "
"this example, we'll just utilize a few of them.  These types can be easily "
"recognized because they start with ``Modelica.`` in the name of the type."
msgstr ""
"不像本章之前例子，我们并没有在本例内定义任何类型。\ "
"相反，我们依赖于在\ :ref:`msl`\ 内定义的类型。\ "
"\ :ref:`msl`\ 包含了许多有用的类型、模型、常量等。\ "
"在本例里，我们只会利用其中的几个。\ "
"这些类型可以很容易识别，因为其名字均以\ ``Modelica.``\ 开头。\ "

#: ../../source/components/packages/fqn.rst:33
msgid ""
"We look more closely at the :ref:`lookup-rules` later in this chapter. For "
"now, it is sufficient to say that all the types starting with ``Modelica.`` "
"exist within the ``Modelica`` package.  In this case, all types start with "
"``Modelica.SIunits``.  ``SIunits`` is a package within the ``Modelica`` "
"package.  The purpose of the ``SIunits`` package is to store type "
"definitions that conform to ISO standard quantities and units."
msgstr ""
"在本章后面，我们会进一步研究\ :ref:`lookup-rules`\ 。\ "
"就目前而言，可以暂时认为所有以\ ``Modelica.``\ "
"开头的类型均存在于\ ``Modelica``\ 包内。\ "
"在此例里，所有的类型均以\ ``Modelica.SIunits``\ 开始。\ "
"\ "
"``SIunits``\ 为\ ``Modelica``\ 包内的一个包。\ "
"\ ``SIunits``\ "
"包的目的是存储符合ISO标准的物理量和量度单位定义。\ "

#: ../../source/components/packages/fqn.rst:43
msgid ""
"As can be seen in the example code, these types are referenced by their "
"\"fully qualified name\".  That means that type name starts with the name of"
" a top-level package (a package that is not contained within another "
"package).  Each ``.`` in the name represents a new child package.  The last "
"name in the sequence identifies that actual type being referenced."
msgstr ""
"在示例代码中可以看出，这些类型是以其“全限定名”引用的。\ "
"这意味着，类型名称的开头是顶层包（不包含在其他包内的包）的名称。\ "
"每个在名称里的\ ``.``\ 代表一个新的子包。\ "
"序列中的最后一个名称标记所引用的实际类型。\ "

#: ../../source/components/packages/fqn.rst:50
msgid ""
"In this case, we are using 5 different types from within the "
"``Modelica.SIunits`` package: ``Voltage``, ``Inductance``, ``Resistance``, "
"``Capacitance`` and ``Current``.  These types provide information about the "
"units for each of these types, limitations on the values of these types "
"(*e.g.*, a capacitance cannot be less than zero), *etc*.  They are defined "
"in the :ref:`msl` as follows:"
msgstr ""
"在本例里，我们从\ ``Modelica.SIunits``\ 包内使用了5种不同的类型：\ "
"\ ``Voltage``\ 、\ ``Inductance``\ 、\ ``Resistance``\ 、\ ``Capacitance``\ 以及\ ``Current``\ 。\ "
"这些类型提供了每种类型的单位，以及对这些类型值所在范围的限制（例如，电容不能小于零）等信息。\ "
"这些类型在\ :ref:`msl`\ 内定义如下："

#: ../../source/components/packages/fqn.rst:75
msgid ""
"Apart from providing better documentation, there is an immediate benefit to "
"associating such types with variables and that is because it enables unit "
"consistency checking of the equations.  For example, note the following "
"equation from this example:"
msgstr "除了能提供更好的文档外，将变量和类型关联起来有一个直接的好处。\ "
"那就是支持方程单位的一致性检查。\ "
"例如，注意本例中的以下等式："

#: ../../source/components/packages/fqn.rst:84
msgid ""
"Clearly, this is a statement of Ohm's law.  But what if we made a mistake "
"and accidentally wrote:"
msgstr "显然，这是对欧姆定律的陈述。\ "
"但是，假若我们犯了一个错误，而将其意外写成了："

#: ../../source/components/packages/fqn.rst:91
msgid ""
"Syntactically speaking, this equation is perfectly legal. Furthermore, if "
"the variable ``i_R``, ``V`` and ``R`` were all declared to have the type "
"``Real``, there would be no issue with this equation.  However, because we "
"know (from the type definitions) that these variables represent a current, a"
" voltage and a resistance, respectively, a Modelica compiler is able to "
"determine (in a completely automatic way using the definitions shown "
"previously) that the left and right hand sides of this equation are "
"inconsistent with respect to physical units.  In other words, by associating"
" a physical type with variables it is possible to detect modeling errors, "
"automatically."
msgstr ""
"在语法上来讲，这个公式是完全合法的。\ "
"再者，若变量\ ``i_R``\ 、\  ``V``\ 、\ ``R``\ 均声明为\ "
"``Real``\ 类型，那么上述方程便没有任何问题。\ "
"然而，因为（从类型定义）我们知道 "
"，这些变量分别表示电流、电压和电阻。\ "
"Modelica语言编译器由此能够确定（完全自动地使用上述定义），这个等式的左侧和右侧的物理单位不一致。\ "
"换句话说，将变量和物理类型相关联可以自动地检查建模错误。\ "
