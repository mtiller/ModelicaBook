# 
msgid ""
msgstr ""
"Project-Id-Version: Modelica by Example 0.2.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-04-14 10:14-0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/components/architectures/int_vs_imp.rst:2
msgid "Interfaces and Implementations"
msgstr "接口和实现"

#: ../../source/components/architectures/int_vs_imp.rst:5
msgid "Conceptual Definitions"
msgstr "概念定义"

#: ../../source/components/architectures/int_vs_imp.rst:7
msgid ""
"In both of the examples we presented in this chapter, we used interface "
"definitions as part of the architecture definition process. The term "
"\"interface\" doesn't come from Modelica itself, it is a term common among "
"computer languages.  In Modelica, we can think of interfaces as models that "
"define all the details of the model **that are externally visible**.  You "
"can think of an interface as a \"shell\" without any internal details.  For "
"this reason, interface models are almost always marked as ``partial``."
msgstr ""
"我们在本章提出的两个例子里，接口定义用作架构定义过程的一部分。\ "
"术语“接口”并非来自Modelica。\ "
"这个词是计算机语言中的一个常用术语。\ "
"在Modelica里，我们可以认为接口是定义了所有\ **外部可见**\ 细节的模型。\ "
"你也可以把一个接口当作没有任何内部细节的“壳”。\ "
"出于这个原因，接口模型几乎总是带有\ ``partial``\ 标记。\ "

#: ../../source/components/architectures/int_vs_imp.rst:16
msgid ""
"Another important concept is that of an \"implementation\".  This is another"
" term borrowed from the world of computer languages. Whereas an interface is"
" used to simply describe the externally visible aspects of a model, an "
"implementation includes internal details as well.  It includes the "
"information required to actually implement that interface.  In some cases, "
"it may only constitute a partial implementation (in which case it should "
"also be marked as ``partial``).  In other cases, it may represent the "
"architecture of a particular subsystem where further implementation details "
"are pushed one additional level down in the model hierarchy (another case of"
" a ``partial`` model).  But most of the time, these implementations will be "
"complete (non-``partial``) models for a particular subsystem."
msgstr ""
"另一个重要的概念就是“实现”。\ "
"这是从计算机语言世界借来的另一个词。\ "
"接口用于简单地描述模型外部可见的部分。\ "
"而实现除此以外还包括了内部细节。\ "
"实现包括真正实现该接口所需的信息。\ "
"某些情况下，该模型可能只是接口的部分实现（这种情况下，它也应该标记为\ ``partial``\ ）。\ "
"而在另一些情况下，该模型可以代表特定子系统的架构。\ "
"其中的进一步实现细节则在推迟到模型层级另一级（这是\ ``partial``\ 模型的另一种情况）。\ "
"不过大部分的时间，这些实现将是特定子系统的完整（非\ ``partial``\ ）模型。\ "

#: ../../source/components/architectures/int_vs_imp.rst:32
msgid "Plug-Compatibility"
msgstr "插件兼容性"

#: ../../source/components/architectures/int_vs_imp.rst:34
msgid ""
"The most important thing we need to consider when we talk about interfaces "
"and implementations is the notion of **plug-compatibility**.  As we already "
"discussed in our elaboration of the :ref:`sensor-comparison` example, a "
"model ``X`` is plug-compatible with a model ``Y`` if for every **public** "
"variable in ``Y``, there is a corresponding public variable in ``X`` with "
"the same name. Furthermore, every such variable in ``X`` must itself be "
"plug-compatible with its counterpart in ``Y``.  This ensures that if you "
"change a component of type ``Y`` into a component of type ``X`` that "
"everything you need (parameters, connectors, etc) will still be there and "
"will still be compatible.  **However, please note** that if ``X`` is plug-"
"compatible with ``Y``, this **does not** imply that ``Y`` is plug-compatible"
" with ``X`` (as we will see in a moment)."
msgstr ""
"当我们谈论接口和实现所要考虑的重中之重就是\ **插件兼容性**\ 的概念。\ "
"我们在\ :ref:`sensor-comparison`\ 例子已经讨论过，\ "
"模型\ ``X``\ 插件兼容于模型\ ``Y``\ 的条件是，每个\ ``Y``\ 的\ **公共**\ 变量都能在\ ``X``\ 找到具有相同名称的对应公共变量。\ "
"此外，每个\ ``X``\ 的上述变量本身必须是插件兼容于其在\ ``Y``\ 内的对应变量。\ "
"这可以确保如果你将\ ``Y``\ 类型的组件更换为\ ``X``\ 类型的组件，你需要的一切（参数，连接器等）将依然存在、并仍将兼容。\ "
"\ **不过**\ ，请注意如果\ ``X``\ 插件兼容于\ ``Y``\ ，这\ **不**\ 意味着\ ``Y``\ 插件兼容于\ ``X``\ （我们稍后会看到）。\ "

#: ../../source/components/architectures/int_vs_imp.rst:48
msgid ""
"Generally speaking, most cases where we concern ourselves with plug-"
"compatibility revolve around whether a given implementation is plug-"
"compatible with a given interface.  As we've seen in these examples (and we "
"will review shortly), the configuration management features in Modelica "
"hinge on the relationship between interfaces and implementations and the "
"process by which configuration management is performed is centered around "
"plug-compatibility."
msgstr ""
"一般来说，大多数情况我们关注的插件兼容性问题是围绕着给定的实施是否插件兼容于给定的接口。\ "
"正如我们在这些例子里看到的一样（我们也马上会回顾），Modelica的配置管理功能依赖于接口和实现间的关系。\ "
"而配置管理的流程则是着围绕插件的兼容性为中心的。\ "

#: ../../source/components/architectures/int_vs_imp.rst:57
msgid "Conclusion"
msgstr "结论"

#: ../../source/components/architectures/int_vs_imp.rst:59
msgid ""
"The bottom line is that it is very useful to not only think in terms of "
"interface and implementation models, but also to create models to formally "
"define interfaces and distinguish them from implementations, since these "
"will be very useful when creating architecture driven models."
msgstr ""
"必须要知道，我们不但应该以接口与实现模型为基础进行思考。\ "
"而且，我们也要正式创建接口模型，并区分接口模型与具体实现。\ "
"因为，在创建架构驱动的模型时，上述思路都非常有用。\ "
