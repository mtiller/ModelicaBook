#
msgid ""
msgstr ""
"Project-Id-Version: Modelica by Example 0.2.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-04-14 10:14-0400\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../source/components/components/population.rst:4
msgid "Lotka-Volterra Equations Revisited"
msgstr "再探猎食者猎物模型"

#: ../../source/components/components/population.rst:6
msgid ""
"In this section, we will revisit the :ref:`lotka-volterra-systems` discussed"
" in the first chapter.  However, this time we will create system models from"
" individual components.  After recreating the behavior shown in the first "
"chapter, we'll expand the set of effects we consider and reconfigure these "
"component models into other system models that demonstrate different "
"dynamics."
msgstr ""
"在本节中，我们将重温第一章的\ :ref:`lotka-volterra-systems`\ 。\ "
"不过，这一次我们将利用单独的组件创建系统模型。\ "
"在重复第一章得到的行为后，我们将扩大考虑的范围。\ "
"我们会重新配置这些组件模型，以创建系统模型去演示不同的动态等。\ "

#: ../../source/components/components/population.rst:14
msgid "Classic Lotka-Volterra"
msgstr "经典猎食者猎物"

#: ../../source/components/components/population.rst:16
msgid ""
"We'll start by looking at the classic Lotka-Volterra system.  In order to "
"create such a system using component models, we will require models to "
"represent the population of both rabbits and foxes as well as models for "
"reproduction, starvation and predation."
msgstr ""
"我们首先观察经典的猎食者猎物系统。\ "
"为了使用组件模型来建立这样一个系统，我们将需要不同模型。\ "
"这包括兔子和狐狸的人口模型，以及代表繁殖、饥饿和捕食的模型。\ "

#: ../../source/components/components/population.rst:22
msgid "Connectors"
msgstr "连接器"

#: ../../source/components/components/population.rst:24
msgid ""
"However, as we learned during our discussion of :ref:`connectors`, before we"
" can start building component models we first need to formally define the "
"information that will be exchanged by interacting components by defining "
"connectors.  The ``connector`` we will use in this section is the "
"``Species`` connector and it is defined as follows:"
msgstr ""
"但是，我们在对\ :ref:`connectors`\ "
"的讨论中了解到了一点。\ "
"在开始建立组件模型前，我们必须先定义相互作用的部件间所交换的信息。\ "
"要做到这点，我们要定义连接器。\ "
"在本节我们会使用的\ ``connector``\ 是\ ``Species``\ 连接器。\ "
"它的定义如下："

#: ../../source/components/components/population.rst:34
msgid ""
"This connector definition is interesting because these definitions do not "
"come from engineering.  Instead, they really arise from ecology.  In this "
"case, our across variable is ``population`` which represents the actual "
"number of animals of a particular species.  Our through variable, indicated "
"by the presence of the ``flow`` qualifier, is ``rate`` which represents the "
"rate at which new animals \"enter\" the component that this connector is "
"attached to."
msgstr ""
"此连接器的定义很有趣。\ "
"因为这些定义并非来自工程领域。\ "
"相反，这些定义其实来源于生态学。\ "
"在这种情况下，我们的横跨变量是\ ``population``\"
" 。\ "
"这代表特定物种动物的实际数量。\ "
"\ ``flow``\ 限定词所标示的通过变量是\ ``rate``\ "
"。\ "
"此变量表示，连接器所在部件的新动物“输入”率。\ "

#: ../../source/components/components/population.rst:43
msgid "Regional Population"
msgstr "区域种群大小"

#: ../../source/components/components/population.rst:45
msgid ""
"To track the population of a given species in one region, we'll use the "
"``RegionalPopulation`` model.  The model has several noteworthy aspects so "
"we'll present the model piece by piece starting with:"
msgstr ""
"要追踪一个地区内一个特定物种的数目，我们将使用\ ``RegionalPopulation``\ "
"模型。\ "
"这个模型有几个值得注意的方面。\ "
"所以我们会分步介绍模型。\ "
"首先："

#: ../../source/components/components/population.rst:58
msgid ""
"The first two lines are as expected.  But after that we see that this model "
"defines a type called ``InitializationOptions``.  The type definition is "
"qualified with the ``encapsulated`` keyword.  This is necessary because the "
"type is being defined within a model and not a package.  Modelica has a rule"
" that if we wish to refer to this type from outside the ``model`` "
"definition, the type definition must be prefixed by ``encapsulated``.  We "
"can see from the definition of this ``enumeration`` that it defines three "
"distinct values: ``Free``, ``FixedPopulation`` and ``SteadyState``.  We'll "
"see how these values will be used shortly."
msgstr ""
"The first two lines are as expected.前两行没有意外。\ "
"但此后，我们看到模型定义了一个名为\ "
"``InitializationOptions``\ 的类型。\ "
"类型定义前添加了\ ``encapsulated``\ 关键字。\ "
"这是必要的。\ "
"因为该类型是在模型而不是包内定义的。\ "
"Modelica有这样的一条规则。\ "
"如果我们想从\ ``model``\ "
"定义外引用此类型，类型定义前必须添加\ ``encapsulated``\ 。\ "
"从定义可以看到，\ ``enumeration``\ "
"定义了三个不同的值：\ ``Free``\ 、\ ``FixedPopulation``\ 以及\ ``SteadyState``\ 。\ "
"我们将很快看到如何使用这些值。\ "

#: ../../source/components/components/population.rst:69
msgid "The first declarations in our ``RegionalPopulation`` model is:"
msgstr "\ ``RegionalPopulation``\ 模型的第一个声明为："

#: ../../source/components/components/population.rst:75
msgid ""
"Note that the first ``parameter``, ``init``, utilizes the "
"``InitializationOptions`` enumeration both to specify its type (the "
"enumeration itself) and its initial value, ``Free``.  Also note the presence"
" of the ``choicesAllMatching`` annotation.  We'll talk more about this "
"``annotation`` later in this chapter, when we are reviewing the concepts "
"introduced here, and in subsequent chapters."
msgstr ""
"需要注意的是\ ``init``\ ，也就是第一个\ ``parameter``\ ，利用了\ "
"``InitializationOptions``\ 枚举值。\ "
"不但以此指定了其类型（为枚举值），而且也以此指定了起初始值\ ``Free``\ "
"。\ "
"还要注意这里有\ ``choicesAllMatching``\ 标注。\ "
"我们会在本章的后面回顾概念时以及随后的章节里更多地讨论\ "
"``annotation``\ 。\ "

#: ../../source/components/components/population.rst:82
msgid "The next declaration is:"
msgstr "紧接的声明是："

#: ../../source/components/components/population.rst:88
msgid ""
"The ``initial_population`` parameter is used to represent the initial value "
"for the population in this region at the start of the simulation.  However, "
"as we will see shortly in the equation section, this value is only used if "
"the value of ``init`` is set to ``FixedPopulation``.  For this reason, the "
"``enable`` annotation on this ``parameter`` is set to "
"``init==InitializationOptions.FixedPopulation``.  This annotation is used to"
" inform Modelica tools of this relationship.  This information can then be "
"taken into account when building graphical user interfaces (*e.g.,* a "
"parameter dialog) associated with this model."
msgstr ""
"\ ``initial_population``\ "
"参数是用来表示在该区域在仿真开始时种群大小的初始值。\ "
"然而，我们在不久后就会在等式区域里看到，只有在\ ``init``\ 值设为\ "
"``FixedPopulation``\ 时，模型才会使用上述值。\ "
"出于这个原因，\ ``parameter``\ 的\ ``enable``\"
" 标注设定为\ ``init==InitializationOptions.FixedPopulation``\ "
"。\ "
"这个标注把上述关系告知了Modelica工具。\ "
"在建立与该模型相关联的图形用户界面（例如参数的对话框）时，工具就可以使用该信息了。\ "

#: ../../source/components/components/population.rst:100
msgid ""
"It is also worth noting the presence of the ``Dialog`` annotation in the "
"definition of ``initial_population``.  This annotation allows the model "
"developer to organize parameters into categories, in this case "
"\"Initialization\".  Tools generally use such information to help structure "
"parameter dialogs."
msgstr ""
"另外值得注意的一点是\ ``initial_population``\ 定义内的\ ``Dialog``\ "
"标注。\ "
"该标注允许模型开发者把参数组织成不同的类别。\ "
"在这种情况下参数在“初始化”类别里。\ "
"Modelica工具通常会使用这些信息去帮助组织参数对话框。\ "

#: ../../source/components/components/population.rst:106
msgid ""
"The last public declaration in the model is for the ``connector`` instance "
"that allows interactions with other components:"
msgstr "模型的最后一次公有声明为\ ``connector``\ 实例。\ "
"该连接器可以让组件与外界其他组件进行相互作用："

#: ../../source/components/components/population.rst:113
msgid ""
"Here we again see the :ref:`placement` annotation which we will again defer "
"talking about for the moment.  This leaves the last declaration, which "
"happens to be ``protected``:"
msgstr ""
"这里我们再次看到了\ :ref:`placement`\ 标注。\ "
"不过，我们还是暂时不对其进行讨论。\ "
"这样就剩下最后一条声明。\ "
"这条声明恰好为\ "
"``protected``\ ："

#: ../../source/components/components/population.rst:121
msgid ""
"This variable represents the number of animals in this region.  It is given "
"a non-zero ``start`` value to avoid the trivial solutions we saw in our "
"earlier discussion of :ref:`steady-state` of Lotka-Volterra systems.  We can"
" also see, from this declaration, that this declaration equates the local "
"variable, ``population``, with the value of the across variable on the "
"``species`` connector, ``species.population``.  In effect, the "
"``population`` variable is an alias for the expression "
"``species.population``."
msgstr ""
"这个变量表示在这个地区的动物总数。\ "
"变量的\ ``start``\ 值非零。\ "
"这样做是为了避免前面对猎食者猎物系统\ :ref:`steady-"
"state`\ 讨论里所看到的平凡解。\ "
"从这个声明我们也可以看到，该声明令局部变量\ ``population``\ 与\ "
"``species``\ 连接器内横跨变量\ ``species.population``\ 的值相等。\ "
"结果，\ ``population``\ 变量其实是\ ``species.population``\ 表达式的别名。\ "

#: ../../source/components/components/population.rst:130
msgid ""
"Now that we have the declarations out of the way, let's look at the "
"equations associated with the ``RegionalPopulation`` model:"
msgstr "以上就是所有声明。\ "
"现在，让我们来看看\ ``RegionalPopulation``\ 模型的相关公式："

#: ../../source/components/components/population.rst:137
msgid ""
"The ``initial equation`` demonstrates the significance that the value of the"
" ``init`` parameter has on the behavior of this component.  In the case that"
" the ``init`` value is equal to the ``FixedPopulation`` value in the "
"``InitializationOptions`` enumeration, an equation is introduced specifying "
"that the value of the ``population`` variable at the start of the simulation"
" is equal to the ``initial_population`` parameter.  If, on the other hand, "
"the value of ``init`` is equal to the ``SteadyState`` value of the "
"enumeration, then an equation is introduced specifying that the rate of "
"population change at the start of the simulation must be zero.  Obviously, "
"if ``init`` is equal to ``Free`` (the last remaining possibility), no "
"initial equation is introduced."
msgstr ""
"\ ``initial equation``\ 展示了\ ``init``\ 参数值对组件行为的作用。\ "
"在一些情况下，\ ``init``\ "
"值等于在\ ``InitializationOptions``\ 枚举内的\ ``FixedPopulation``\ 值。\ "
"此时模型会引入一个方程，以指定在仿真开始时的\ ``population``\ 变量的值等于\ "
"``initial_population``\ 参数。\ "
"在另一些情况下，\ ``init``\ 值等于\ ``SteadyState``\ 枚举值。\ "
"这时模型引入等式，以指定仿真开始时的种群大小变化速率必须为零。\ "
"很显然，如果\ ``init``\ 等于\ ``Free``\ （最后剩下的可能选择），那模型就没有初始方程。\ "

#: ../../source/components/components/population.rst:150
msgid ""
"Within the ``equation`` section, we see that the rate at which the "
"``population`` changes is equal to the value of the ``flow`` variable on the"
" ``species`` connector, ``species.rate``.  Again, recall the sign convention"
" that a positive value for a ``flow`` variable means a flow into the "
"component and the fact that this equation is consistent with that sign "
"convention (*i.e.,* a positive value for ``species.rate`` will have the "
"effect of increasing the ``population`` within the region)."
msgstr ""
"在\ ``equation``\ 区域，我们看到\ ``population``\ 变化率等于\ ``species``\ 连接器内\ "
"``flow``\ 变量\ ``species.rate``\ 的值。\ "
"再一次，我们要记得变量的正负号约定。\ "
"\ ``flow``\ 变量正值意味着流入组件内。\ "
"上述公式与正负号约定相一致（即若\ ``species.rate``\ 为正，则会让区域内\ ``population``\ 增加）。\ "

#: ../../source/components/components/population.rst:161
msgid ""
"The last thing worth noting about the model is the presence of the "
"``assert`` call in the ``equation`` section.  This is used to define a model"
" boundary (*i.e.,* a point beyond which the equations in the model are not "
"valid).  It is used to enforce the constraint that the population within a "
"region cannot be less than zero.  If a solution is ever found where the "
"constraint is violated, the resulting error message will be \"Population "
"must be greater than zero\"."
msgstr ""
"值得一提的最后一点是模型是在\ ``equation``\ 区域内的\ ``assert``\ 调用。\ "
"这是用来定义模型的边界（即令模型中的方程无效的点）。\ "
"该语句用于实行区域内人口不能小于零这一约束。\ "
"若某个解被发现违反约束，模型就会产生“人口必须大于零”的错误信息。\ "

#: ../../source/components/components/population.rst:169
msgid ""
"This model also has an ``Icon`` annotation associated with the model "
"definition.  As usual, the ``Icon`` annotation is not included in the source"
" listing.  But when this component model is rendered within a system model, "
"its icon will look like this:"
msgstr ""
"这个模型在定义里也有相关的\ ``Icon``\ 标注。\ "
"像往常一样，\ ``Icon``\ "
"标注不包含在显示。\ "
"但是，当这个组件模型是在系统模型内渲染后，其图标看起来就像这样："

#: ../../source/components/components/population.rst:181
msgid "Reproduction"
msgstr "繁殖"

#: ../../source/components/components/population.rst:183
msgid ""
"The first real effect we will examine is reproduction.  As we know from our "
"previous discussion, the growth in a given population due to reproduction is"
" proportional to the number of animals of that species in a given region.  "
"As a result, we can describe reproduction very succinctly as:"
msgstr ""
"我们将研究的第一个真正的效应是繁殖。\ "
"从前面的讨论我们知道，由繁殖带来的种群数量增长正比于该区域中动物的数量。\ "
"因此，我们可以非常简洁地将繁殖描述为："

#: ../../source/components/components/population.rst:193
msgid ""
"where ``alpha`` is the proportionality constant.  However, the simplicity "
"and clarity of this model is due mostly to the inheritance of the "
"``SinkOrSource`` model in much the same way that our \"DRY\" :ref"
":`electrical-components` benefited from inheriting the ``TwoPin`` model."
msgstr ""
"其中\ ``alpha``\ 为比例常数。\ "
"不过，这个模型之所以简单明了，主要要归功于其对\ ``SinkOrSource``\ 模型的继承。\ "
"此前的“DRY”\ :ref:`electrical-components`\ 也得益于对\ ``TwoPin``\ 模型的继承。\ "
"因此在这点上，两个继承的作用别无二致。\ "

#: ../../source/components/components/population.rst:199
msgid ""
"The ``SinkOrSource`` model is a starting point for any model that either "
"creates or destroys animals in a population.  It is defined as follows:"
msgstr "\ ``SinkOrSource``\ 模型任何增加或减少动物数的模型的基点。\ "
"其定义如下："

#: ../../source/components/components/population.rst:207
msgid ""
"To understand these equations it is first necessary to understand that any "
"model that ``extends`` from ``SinkOrSource`` will generally be connected to "
"a ``RegionalPopulation`` instance (but will not, itself, **be** a "
"``RegionalPopulation`` model).  This means that if the ``flow`` variable "
"``species.rate`` in such an instance is positive, it will have the effect of"
" pulling animals **out** of the ``RegionalPopulation`` model.  Looking at "
"the ``SinkOrSource`` model in this way, we can see that the variable "
"``decline`` is simply an alias for ``species.rate``.  In other words, when "
"``decline`` has a positive value, ``species.rate`` will have a positive "
"value and, therefore, any ``RegionalPopulation`` that this ``SinkOrSource`` "
"instance is connected to will suffer a drain on its population. Conversely, "
"the ``growth`` variable is positive when ``species.rate`` is negative.  In "
"that case, the connected ``RegionalPopulation`` model will see an increase "
"in species population."
msgstr ""
"要理解这些方程，首先要理解一点。\ "
"任何以\ ``SinkOrSource``\ 为基础\ ``extends``\ 的模型，通常都将连接到\ "
"``RegionalPopulation``\ 实例（但本身不会\ **是**\ 一个\ ``RegionalPopulation``\ 模型）。\ "
"这意味着，如果实例的\ ``flow``\ 变量\ ``species.rate``\ 为正时，模型将动物从\ "
"``RegionalPopulation``\ 模型内抽\ **出来**\ 。\ "
"通过观察\ ``SinkOrSource``\ 模型，我们可以看到变量\ ``decline``\ 只是\ ``species.rate``\ 的一个别名。\ "
"换句话说，若\ ``decline``\ 为正那么\ ``species.rate``\ 也会为正。\ "
"因此，任何与此\ ``SinkOrSource``\ 实例连接的\ ``RegionalPopulation``\ 其种群大小都会受到损失。\ "
"相反，当\ ``species.rate``\ 为负时，\ ``growth``\ 变量就会为正。\ "
"在这种情况下，所连接的\ ``RegionalPopulation``\ 其种群大小将会增加。\ "

#: ../../source/components/components/population.rst:223
msgid ""
"By defining the ``SinkOrSource`` model and inheriting from it, much of this "
"complexity is hidden.  As a result, models like ``Reproduction`` can have "
"equations written in a way that make their behavior more intuitive, *e.g.,* "
"``growth = alpha*species.population``."
msgstr ""
"通过定义并继承\ ``SinkOrSource``\ 模型可以隐藏大部分复杂性。\ "
"这样一来，像\ ``Reproduction``\ "
"这样的模型可以将方程写得更直观，更好地反映模型的行为。\ "
"例如：\ ``growth = alpha*species.population``\ 。"

#: ../../source/components/components/population.rst:228
msgid ""
"Although not shown, the ``Icon`` for the ``Reproduction`` model is rendered "
"as:"
msgstr "虽然先前没有显示，\ ``Icon``\ 为\ ``Reproduction``\ 模型如下所示："

#: ../../source/components/components/population.rst:236
msgid "Starvation"
msgstr "饥饿"

#: ../../source/components/components/population.rst:238
msgid ""
"Just like the ``Reproduction`` model just described, the ``Starvation`` "
"model also inherits from the ``SinkOrSource`` model. However, its behavior "
"with respect to the ``decline`` variable, is described as follows:"
msgstr ""
"正如先前介绍的\ ``Reproduction``\ 模型一样，\ ``Starvation``\ 模型也继承了\ ``SinkOrSource``\ 模型。\ "
"不过，模型与\ ``decline``\ 变量有关的行为可以描述如下："

#: ../../source/components/components/population.rst:255
msgid "Predation"
msgstr "猎食"

#: ../../source/components/components/population.rst:257
msgid ""
"The last effect we need to consider before building a system model to "
"represent the classic Lotka-Volterra behavior is a model for predation."
msgstr "建立经典猎食者猎物系统模型前，我们需要考虑最后一个效应是猎食模型。\ "

#: ../../source/components/components/population.rst:261
msgid ""
"Recall our previous discussion of the ``SinkOrSource`` model and the "
"potential confusion associated with sign conventions.  The ``SinkOrSource`` "
"model was designed to work with effects that only interacted with a single "
"``RegionalPopulation`` (since it had only one ``Species`` connector).  In "
"order to address the same potential sign convention confusion for effects "
"that involve interactions between two different regional populations, the "
"following ``partial`` model, ``Interaction`` was defined:"
msgstr ""
"回想此前的\ ``SinkOrSource``\ 模型以及与正负号约定相关的潜在问题等等的讨论。\ "
"\ ``SinkOrSource``\ "
"模型设计时仅仅考虑了与一个\ ``RegionalPopulation``\ 进行交互\ "
"（因为模型只有一个\ ``Species``\ 连接器）。\ "
"为了解决可能的正负号规定混淆问题，对于涉及两个不同地区种群之间相互效应，\ "
"我们定义了下面的\ ``partial``\ 模型\ ``Interaction``\ ： "

#: ../../source/components/components/population.rst:274
msgid ""
"Again, we have the concepts of growth and decline variables.  However this "
"time we have two version of each.  One is associated with the ``a`` "
"connector and the other is associated with the ``b`` connector."
msgstr ""
"再一次，我们定义了有增长变量以及减少变量。\ "
"但是这一次，有每个变量均有两个版本。\ "
"其中一个与\ ``a``\ 连接器相关联，另一个则与\ ``b``\ 连接器相关联。\ "

#: ../../source/components/components/population.rst:278
msgid "Using these definitions, we can define ``Predation`` very simply as:"
msgstr "使用上述定义，我们很容易可以定义下面的\ ``Predation``\ ："

#: ../../source/components/components/population.rst:284
msgid ""
"This model captures the effect that the growth in the \"B\" (predator) "
"population is proportional to the product of the predator and prey "
"populations.  Similarly, the decline in the \"A\" (prey) population is also "
"proportional the product of the predator and prey populations (although with"
" a different proportionality constant)."
msgstr ""
"此模型描述了，“B”（掠食者）种群大小增长与捕食者以及猎物种群大小两者乘积成正比。\ "
"同样，“A”（猎物）种群大小的减少也与捕食者以及猎物的种群大小这两者乘积成正比（虽然使用的是另一个比例常数）。\ "

#: ../../source/components/components/population.rst:290
msgid ""
"Although not shown, the ``Icon`` for the ``Predation`` model is rendered as:"
msgstr "虽然先前没有显示，\ ``Predation``\ 模型的\ ``Icon``\ 如下所示："

#: ../../source/components/components/population.rst:297
msgid ""
"Note that the ``Predation`` model is asymmetric.  The ``b`` connector should"
" be connected to the predator population and the ``a`` connector should be "
"connected to the prey population.  This is reinforced by the image and "
"asymmetry of the icon itself."
msgstr ""
"需要注意的是\ ``Predation``\ 模型并不对称的。\ "
"\ ``b``\ 连接器应连接到猎食者种群。\ "
"而\ ``a``\ 连接器应连接到猎物种群。\ "
"模型的图像以及不对称的图标也强调了这一点。\ "

#: ../../source/components/components/population.rst:303
msgid "Classic System Model"
msgstr "经典系统模型"

#: ../../source/components/components/population.rst:305
msgid ""
"With all of these components in hand, we can very easily construct a "
"component-oriented version of the classic Lotka-Volterra behavior by "
"dragging and dropping the components into the following system "
"configuration:"
msgstr "有了上述组件，我们就可以很容易地构建面向组件版本的经典猎食者猎物系统。\ "
"通过拖放组件，可以得到以下系统配置："

#: ../../source/components/components/population.rst:316
msgid ""
"Here we see that the ``Starvation`` model is attached to the ``foxes`` "
"population while the ``Reproduction`` model is attached to the ``rabbits`` "
"population.  The ``Predation`` model is connected to both populations with "
"the ``a`` (prey) connector attached to the ``rabbits`` and the ``b`` "
"(predator) connector attached to the ``foxes``."
msgstr ""
"这里我们看到\ ``Starvation``\ 模型连接到\ ``foxes``\ 种群上。\ "
"而\ ``Reproduction``\ "
"模型则连接到了\ ``rabbits``\ 种群。\ "
"\ ``Predation``\ 模型连接则同时连接到两个种群上。\ "
"\ ``a``\ "
"（猎物）连接器连接到\ ``rabbits``\ 处。\ "
"而\ ``b``\ （捕食）连接器则连接到\ ``foxes``\ 处。\ "

#: ../../source/components/components/population.rst:322
msgid ""
"As we can see from the following plot, the behavior of this system is "
"identical to the one presented in our earlier discussion of :ref:`lotka-"
"volterra-systems`:"
msgstr "我们可以从下面的图中看出，这个系统的行为等同于之前讨论的\ :ref:`lotka-volterra-systems`\ 的结果："

#: ../../source/components/components/population.rst:329
msgid "Introducing a Third Species"
msgstr "引入第三个物种"

#: ../../source/components/components/population.rst:331
msgid ""
"As we will see over and over again, there is an initial investment in "
"building component models over simply typing the equations that they "
"encapsulate.  But there is also a significant \"payoff\" to this process "
"because of the schematic based system composition that is then possible as a"
" result.  In the context of the Lotka-Volterra example, this is exemplified "
"by the addition of a third species, wolves, to the classic Lotka-Volterra "
"system."
msgstr ""
"我们将一而再地看到，建立组件模型对比直接写出其封装的公式而言，需要一定的初始投入。\ "
"但这个过程也有显著的“回报”。\ "
"因为作为结果，我们就可以基于概要地去组合系统。\ "
"例如对于猎食者猎物系统，我们可以在经典的猎食者猎物系统添加第三个物种狼。\ "

#: ../../source/components/components/population.rst:340
msgid "Adding Wolves"
msgstr "引入狼群"

#: ../../source/components/components/population.rst:342
msgid ""
"The creation of a model with a third species does not require any additional"
" component models to be defined.  Instead, we can reuse not only our "
"existing models for ``Predation``, ``Starvation`` and "
"``RegionalPopulation``, but we can also reuse the ``ClassicLotkaVolterra`` "
"model itself:"
msgstr ""
"要建立带有第三个物种模型，并不需要定义任何其他组件模型。\ "
"相反，我们不但可以重用现有的\ ``Predation``\ 、\ "
"``Starvation``\ 、\ ``RegionalPopulation``\ 模型，我们还可以重用\ "
"``ClassicLotkaVolterra``\ 模型本身："

#: ../../source/components/components/population.rst:351
msgid ""
"Such a model would not typically be created by typing in the source code you"
" see above.  Instead, within a graphical development environment it would "
"take less than a minute to assemble such a system by augmenting the existing"
" ``ClassicLotkaVolterra`` model.  When visualized, the schematic for the "
"resulting system is rendered as:"
msgstr ""
"你通常不会被通过键入上述源代码去建立这样的模型。\ "
"相反，在一个图形化开发环境里，通过扩大现有的\ ``ClassicLotkaVolterra``\ "
"模型去组装这样的系统，将需要不到一分钟。\ "
"可视化后，生成系统的示意图为如下所示："

#: ../../source/components/components/population.rst:366
msgid "Resulting Dynamics"
msgstr "变更后的动态"

#: ../../source/components/components/population.rst:368
msgid ""
"By creating such a model, we can quickly explore the differences in system "
"dynamics between the classic model and this three species model.  The "
"following plot shows how these three species interact:"
msgstr "通过建立这样一个模型，我们可以很容易观察经典模型与三种群模型在系统动力学之间的差异。\ "
"下面的图显示了这三个物种是进行如何相互作用的："

#: ../../source/components/components/population.rst:375
msgid ""
"By using the ``init`` parameter in the various ``RegionalPopulation`` "
"instances, we can also quickly create a model to solve for the equilibrium "
"population levels for all three species:"
msgstr ""
"通过在不同的\ ``RegionalPopulation``\ 实例内的\ ``init``\ "
"参数，我们还可以快速创建一个模型来求解三个种群的在平衡态的大小。\ "

#: ../../source/components/components/population.rst:382
msgid ""
"All that is required in this model is to extend from the ``ThirdSpecies`` "
"model and modify the ``init`` parameter for each of the underlying species "
"populations.  Simulating this model gives us the equilibrium population "
"level for each species:"
msgstr ""
"需要做的仅仅是以\ ``ThirdSpecies``\ 模型为基础进行扩展，\ "
"然后在包含的每个种群模型里修改\ ``init``\ 参数。\ "
"对模型进行仿真就可以得到每个物种在平衡态的种群大小"

#: ../../source/components/components/population.rst:390
msgid ""
"From an ecological standpoint, we can already make an interesting "
"observation about this system.  If we start it from a non-equilibrium "
"condition the system quickly goes unstable.  In other words, the "
"introduction of wolves into the otherwise stable eco-system involving only "
"rabbits and foxes has a significant impact on the population dynamics."
msgstr ""
"从生态学的角度来看，我们已可以对这个系统做出一个有趣的观察。\ "
"如果我们从一个非平衡条件启动仿真，系统将迅速变为不稳定。\ "
"换句话说，引入狼群对原本稳定、只涉及兔子狐狸的生态系统内的种群动态产生了显著影响。\ "
